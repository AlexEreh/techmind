<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/api/docs/GOTENBERG_SETUP.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/docs/GOTENBERG_SETUP.md" />
              <option name="updatedContent" value="# Настройка Gotenberg Connection&#10;&#10;## Описание&#10;&#10;Gotenberg клиент теперь интегрирован в приложение через Uber FX dependency injection и автоматически инициализируется при старте приложения.&#10;&#10;## Конфигурация&#10;&#10;### dev.yml / prod.yml&#10;&#10;```yaml&#10;gotenberg:&#10;  url: &quot;http://localhost:3000&quot;  # URL Gotenberg сервиса&#10;  enabled: true                  # Включить/выключить Gotenberg&#10;  timeout: 60                    # Таймаут в секундах (по умолчанию 60)&#10;```&#10;&#10;### Параметры&#10;&#10;- **url** - URL Gotenberg API (обязательный)&#10;- **enabled** - Флаг включения/выключения сервиса. Если `false`, клиент не будет создан&#10;- **timeout** - Таймаут HTTP запросов в секундах (по умолчанию 60)&#10;&#10;## Docker Compose&#10;&#10;Gotenberg добавлен в `docker-compose.dev.yml`:&#10;&#10;```yaml&#10;gotenberg:&#10;  image: gotenberg/gotenberg:8&#10;  ports:&#10;    - &quot;3000:3000&quot;&#10;  command:&#10;    - &quot;gotenberg&quot;&#10;    - &quot;--api-timeout=60s&quot;&#10;    - &quot;--log-level=info&quot;&#10;```&#10;&#10;### Запуск&#10;&#10;```bash&#10;# Запустить все сервисы включая Gotenberg&#10;docker-compose -f docker-compose.dev.yml up -d&#10;&#10;# Проверить статус Gotenberg&#10;curl http://localhost:3000/health&#10;```&#10;&#10;## Использование в коде&#10;&#10;Gotenberg клиент автоматически инжектируется в сервисы через FX:&#10;&#10;```go&#10;// В document service&#10;func NewService(&#10;&#9;documentRepo repo.DocumentRepository,&#10;&#9;documentTagRepo repo.DocumentTagRepository,&#10;&#9;tagRepo repo.TagRepository,&#10;&#9;folderRepo repo.FolderRepository,&#10;&#9;minioClient *minio.Client,&#10;&#9;gotenbergClient *gotenberg.Client, // Автоматически инжектируется&#10;) service.DocumentService {&#10;&#9;// ...&#10;}&#10;```&#10;&#10;## Отключение Gotenberg&#10;&#10;Если Gotenberg не требуется, можно отключить его:&#10;&#10;```yaml&#10;gotenberg:&#10;  url: &quot;http://localhost:3000&quot;&#10;  enabled: false  # Отключить&#10;  timeout: 60&#10;```&#10;&#10;При `enabled: false`:&#10;- Gotenberg клиент не будет создан (`nil`)&#10;- Функции, требующие Gotenberg, будут возвращать ошибку&#10;- Приложение продолжит работать без конвертации документов&#10;&#10;## Архитектура&#10;&#10;```&#10;app/app.go&#10;  ├── fx.Provide(gotenberg.New)  // Регистрация провайдера&#10;  └── connections/gotenberg/&#10;      └── gotenberg.go            // Инициализация клиента&#10;          ├── Читает config&#10;          ├── Создает HTTP client с таймаутом&#10;          ├── Создает Gotenberg client&#10;          └── Регистрирует lifecycle hooks&#10;```&#10;&#10;## Проверка работоспособности&#10;&#10;### 1. Проверка конфигурации&#10;&#10;```bash&#10;# Проверить что Gotenberg запущен&#10;curl http://localhost:3000/health&#10;&#10;# Ожидаемый ответ:&#10;{&#10;  &quot;status&quot;: &quot;up&quot;,&#10;  &quot;details&quot;: {&#10;    &quot;chromium&quot;: {&quot;status&quot;: &quot;up&quot;},&#10;    &quot;libreoffice&quot;: {&quot;status&quot;: &quot;up&quot;}&#10;  }&#10;}&#10;```&#10;&#10;### 2. Проверка версии&#10;&#10;```bash&#10;curl http://localhost:3000/version&#10;# Ожидаемый ответ: 8.x.x&#10;```&#10;&#10;### 3. Тест конвертации&#10;&#10;```bash&#10;# Создать тестовый HTML файл&#10;echo &quot;&lt;h1&gt;Test&lt;/h1&gt;&quot; &gt; test.html&#10;&#10;# Конвертировать в PDF&#10;curl --request POST \&#10;  --url http://localhost:3000/forms/chromium/convert/html \&#10;  --form files=@test.html \&#10;  --output test.pdf&#10;```&#10;&#10;## Troubleshooting&#10;&#10;### Gotenberg не запускается&#10;&#10;```bash&#10;# Проверить логи&#10;docker-compose -f docker-compose.dev.yml logs gotenberg&#10;&#10;# Перезапустить контейнер&#10;docker-compose -f docker-compose.dev.yml restart gotenberg&#10;```&#10;&#10;### Таймауты при конвертации&#10;&#10;Увеличьте таймаут в конфигурации:&#10;&#10;```yaml&#10;gotenberg:&#10;  url: &quot;http://localhost:3000&quot;&#10;  enabled: true&#10;  timeout: 120  # Увеличить до 120 секунд&#10;```&#10;&#10;### Ошибка &quot;connection refused&quot;&#10;&#10;Проверьте что:&#10;1. Gotenberg запущен: `docker ps | grep gotenberg`&#10;2. URL правильный в конфиге&#10;3. Порты доступны: `netstat -an | grep 3000`&#10;&#10;## Production настройка&#10;&#10;Для production окружения в `prod.yml`:&#10;&#10;```yaml&#10;gotenberg:&#10;  url: &quot;http://gotenberg:3000&quot;  # Внутренний DNS в Docker&#10;  enabled: true&#10;  timeout: 90&#10;```&#10;&#10;В docker-compose.yml:&#10;&#10;```yaml&#10;gotenberg:&#10;  image: gotenberg/gotenberg:8&#10;  restart: always&#10;  networks:&#10;    - backend&#10;  command:&#10;    - &quot;gotenberg&quot;&#10;    - &quot;--api-timeout=90s&quot;&#10;    - &quot;--log-level=error&quot;&#10;  deploy:&#10;    resources:&#10;      limits:&#10;        memory: 2G&#10;      reservations:&#10;        memory: 1G&#10;```&#10;&#10;## См. также&#10;&#10;- [Gotenberg Documentation](https://gotenberg.dev/)&#10;- [Preview Generation Guide](./PREVIEW_GENERATION.md)&#10;- [API Documentation](./API_GUIDE.md)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/docs/INTEGRATION_SUMMARY.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/docs/INTEGRATION_SUMMARY.md" />
              <option name="updatedContent" value="# Интеграция Gotenberg и генерация PDF превью&#10;&#10;## Сводка изменений&#10;&#10;Была реализована полная интеграция Gotenberg для конвертации документов в PDF превью.&#10;&#10;## Файлы изменены&#10;&#10;### 1. Конфигурация&#10;&#10;#### `pkg/config/config.go`&#10;- ✅ Добавлена секция `Gotenberg` с полями:&#10;  - `URL` - адрес Gotenberg API&#10;  - `Enabled` - флаг включения/выключения&#10;  - `Timeout` - таймаут запросов в секундах&#10;&#10;#### `dev.yml`&#10;- ✅ Добавлена конфигурация Gotenberg:&#10;```yaml&#10;gotenberg:&#10;  url: &quot;http://localhost:3000&quot;&#10;  enabled: true&#10;  timeout: 60&#10;```&#10;&#10;#### `docker-compose.dev.yml`&#10;- ✅ Исправлен сервис Gotenberg с правильным маппингом портов&#10;- ✅ Добавлены команды для настройки таймаута и логирования&#10;&#10;### 2. Подключение&#10;&#10;#### `internal/connections/gotenberg/gotenberg.go` (НОВЫЙ)&#10;- ✅ Создан провайдер для Uber FX&#10;- ✅ Инициализация Gotenberg клиента с настройками из конфига&#10;- ✅ Поддержка отключения через флаг `enabled`&#10;&#10;#### `app/app.go`&#10;- ✅ Добавлен импорт `gotenberg` connection&#10;- ✅ Зарегистрирован `gotenberg.New` в `fx.Provide`&#10;&#10;### 3. Сервис документов&#10;&#10;#### `internal/service/document/document.go`&#10;- ✅ Добавлены импорты `bytes`, `strings`, `gotenberg`&#10;- ✅ Добавлены поля в структуру `documentService`:&#10;  - `gotenbergClient *gotenberg.Client`&#10;  - `gotenbergEnabled bool`&#10;- ✅ Обновлен конструктор `NewService` с параметром `gotenbergClient`&#10;- ✅ Реализована функция `GeneratePDFPreview()` - основная функция конвертации&#10;- ✅ Добавлена функция `isConvertibleToPDF()` - проверка поддерживаемых типов&#10;- ✅ Добавлена функция `isOfficeDocument()` - проверка Office документов&#10;&#10;#### `internal/service/service.go`&#10;- ✅ Добавлен метод `GeneratePDFPreview` в интерфейс `DocumentService`&#10;&#10;### 4. Документация&#10;&#10;#### `docs/PREVIEW_GENERATION.md` (НОВЫЙ)&#10;- ✅ Полное описание функции генерации превью&#10;- ✅ Поддерживаемые форматы файлов&#10;- ✅ Примеры использования&#10;- ✅ Архитектура и процесс генерации&#10;- ✅ Обработка ошибок&#10;- ✅ Настройка и troubleshooting&#10;&#10;#### `docs/GOTENBERG_SETUP.md` (НОВЫЙ)&#10;- ✅ Инструкции по настройке Gotenberg&#10;- ✅ Конфигурация для dev/prod&#10;- ✅ Docker Compose настройки&#10;- ✅ Troubleshooting&#10;&#10;#### `internal/service/document/example_preview_generation.go` (НОВЫЙ)&#10;- ✅ Примеры использования функции&#10;- ✅ Пример массовой генерации превью&#10;- ✅ Пример проверки поддерживаемых типов&#10;&#10;## Функциональность&#10;&#10;### GeneratePDFPreview&#10;&#10;Основная функция для конвертации документов:&#10;&#10;```go&#10;func (s *documentService) GeneratePDFPreview(ctx context.Context, documentID uuid.UUID) error&#10;```&#10;&#10;**Что делает:**&#10;1. Проверяет доступность Gotenberg&#10;2. Загружает документ из БД&#10;3. Проверяет поддержку формата&#10;4. Скачивает оригинальный файл из MinIO&#10;5. Конвертирует через Gotenberg API&#10;6. Загружает PDF в MinIO (`{company_id}/previews/{preview_id}.pdf`)&#10;7. Обновляет `preview_file_path` в БД&#10;8. При ошибке откатывает изменения&#10;&#10;**Поддерживаемые форматы:**&#10;- Microsoft Office: .docx, .xlsx, .pptx, .doc, .xls, .ppt&#10;- OpenDocument: .odt, .ods, .odp&#10;- Другие: .rtf, .html&#10;&#10;## Использование&#10;&#10;### Простой пример&#10;&#10;```go&#10;// Генерация превью для документа&#10;err := documentService.GeneratePDFPreview(ctx, documentID)&#10;if err != nil {&#10;    log.Printf(&quot;Error: %v&quot;, err)&#10;}&#10;&#10;// Получение URL превью&#10;previewURL, err := documentService.GetPreviewURL(ctx, documentID)&#10;```&#10;&#10;### Асинхронная генерация&#10;&#10;```go&#10;// После загрузки документа&#10;document, err := docService.Upload(ctx, input)&#10;if err != nil {&#10;    return nil, err&#10;}&#10;&#10;// Генерируем превью в фоне&#10;go func() {&#10;    err := docService.GeneratePDFPreview(context.Background(), document.ID)&#10;    if err != nil {&#10;        log.Printf(&quot;Preview generation failed: %v&quot;, err)&#10;    }&#10;}()&#10;```&#10;&#10;## Запуск&#10;&#10;### Локальная разработка&#10;&#10;```bash&#10;# 1. Запустить сервисы&#10;docker-compose -f docker-compose.dev.yml up -d&#10;&#10;# 2. Проверить Gotenberg&#10;curl http://localhost:3000/health&#10;&#10;# 3. Запустить приложение&#10;cd apps/api&#10;go run cmd/main.go&#10;```&#10;&#10;### Проверка работы&#10;&#10;```bash&#10;# Health check&#10;curl http://localhost:3000/health&#10;&#10;# Version check&#10;curl http://localhost:3000/version&#10;```&#10;&#10;## Отключение Gotenberg&#10;&#10;Если Gotenberg не нужен, можно отключить в конфиге:&#10;&#10;```yaml&#10;gotenberg:&#10;  url: &quot;http://localhost:3000&quot;&#10;  enabled: false  # Отключить&#10;  timeout: 60&#10;```&#10;&#10;При отключении:&#10;- Клиент не создается (`nil`)&#10;- Функция `GeneratePDFPreview` вернет ошибку&#10;- Остальные функции работают нормально&#10;&#10;## Тестирование&#10;&#10;```bash&#10;# Тесты сервиса документов&#10;cd apps/api&#10;go test ./internal/service/document/... -v&#10;&#10;# Проверка компиляции&#10;go build ./...&#10;```&#10;&#10;## Следующие шаги&#10;&#10;1. ✅ Добавить HTTP endpoint для генерации превью&#10;2. ✅ Реализовать фоновую обработку через очередь&#10;3. ✅ Добавить метрики и мониторинг&#10;4. ✅ Настроить автоматическую генерацию при загрузке&#10;&#10;## Полезные ссылки&#10;&#10;- [Gotenberg Documentation](https://gotenberg.dev/)&#10;- [MinIO Go Client](https://min.io/docs/minio/linux/developers/go/minio-go.html)&#10;- [Uber FX](https://uber-go.github.io/fx/)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/internal/service/company_user_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/internal/service/company_user_service.go" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;techmind/internal/repo&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;type companyUserService struct {&#10;&#9;repo repo.CompanyUserRepository&#10;}&#10;&#10;func NewCompanyUserService(repo repo.CompanyUserRepository) CompanyUserService {&#10;&#9;return &amp;companyUserService{repo: repo}&#10;}&#10;&#10;func (s *companyUserService) GetUserRole(ctx context.Context, userID, companyID uuid.UUID) (int, error) {&#10;&#9;return s.repo.GetUserRole(ctx, userID, companyID)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/internal/service/document/example_preview_generation.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/internal/service/document/example_preview_generation.go" />
              <option name="updatedContent" value="package document&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;fmt&quot;&#10;&#9;&quot;log&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Пример использования GeneratePDFPreview&#10;// Эта функция демонстрирует как сгенерировать PDF превью для документа&#10;func ExampleGeneratePDFPreview(docService *documentService, documentID uuid.UUID) {&#10;&#9;ctx := context.Background()&#10;&#10;&#9;// Генерируем PDF превью для документа&#10;&#9;err := docService.GeneratePDFPreview(ctx, documentID)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;Ошибка при генерации превью: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Println(&quot;✓ PDF превью успешно сгенерировано&quot;)&#10;&#10;&#9;// Получаем URL превью&#10;&#9;previewURL, err := docService.GetPreviewURL(ctx, documentID)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;Ошибка при получении URL превью: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;fmt.Printf(&quot;✓ URL превью: %s\n&quot;, previewURL)&#10;}&#10;&#10;// Пример массовой генерации превью для всех документов компании&#10;func ExampleBatchGeneratePreviews(docService *documentService, companyID uuid.UUID) {&#10;&#9;ctx := context.Background()&#10;&#10;&#9;// Получаем все документы компании&#10;&#9;documents, err := docService.GetByCompany(ctx, companyID)&#10;&#9;if err != nil {&#10;&#9;&#9;log.Printf(&quot;Ошибка при получении документов: %v&quot;, err)&#10;&#9;&#9;return&#10;&#9;}&#10;&#10;&#9;successCount := 0&#10;&#9;errorCount := 0&#10;&#10;&#9;// Генерируем превью для каждого документа&#10;&#9;for _, doc := range documents {&#10;&#9;&#9;// Проверяем, нет ли уже превью&#10;&#9;&#9;if doc.Document.PreviewFilePath != nil {&#10;&#9;&#9;&#9;fmt.Printf(&quot;⊘ Документ %s уже имеет превью, пропускаем\n&quot;, doc.Document.Name)&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;// Генерируем превью&#10;&#9;&#9;err := docService.GeneratePDFPreview(ctx, doc.Document.ID)&#10;&#9;&#9;if err != nil {&#10;&#9;&#9;&#9;log.Printf(&quot;✗ Ошибка при генерации превью для %s: %v\n&quot;, doc.Document.Name, err)&#10;&#9;&#9;&#9;errorCount++&#10;&#9;&#9;&#9;continue&#10;&#9;&#9;}&#10;&#10;&#9;&#9;fmt.Printf(&quot;✓ Превью сгенерировано для: %s\n&quot;, doc.Document.Name)&#10;&#9;&#9;successCount++&#10;&#9;}&#10;&#10;&#9;fmt.Printf(&quot;\nИтого: успешно=%d, ошибок=%d, всего=%d\n&quot;, successCount, errorCount, len(documents))&#10;}&#10;&#10;// Пример проверки поддерживаемых типов файлов&#10;func ExampleCheckSupportedTypes(docService *documentService) {&#10;&#9;supportedTypes := []struct {&#10;&#9;&#9;mimeType    string&#10;&#9;&#9;description string&#10;&#9;}{&#10;&#9;&#9;{&quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document&quot;, &quot;Microsoft Word (.docx)&quot;},&#10;&#9;&#9;{&quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;, &quot;Microsoft Excel (.xlsx)&quot;},&#10;&#9;&#9;{&quot;application/vnd.openxmlformats-officedocument.presentationml.presentation&quot;, &quot;Microsoft PowerPoint (.pptx)&quot;},&#10;&#9;&#9;{&quot;application/msword&quot;, &quot;Microsoft Word 97-2003 (.doc)&quot;},&#10;&#9;&#9;{&quot;application/vnd.ms-excel&quot;, &quot;Microsoft Excel 97-2003 (.xls)&quot;},&#10;&#9;&#9;{&quot;application/vnd.ms-powerpoint&quot;, &quot;Microsoft PowerPoint 97-2003 (.ppt)&quot;},&#10;&#9;&#9;{&quot;application/vnd.oasis.opendocument.text&quot;, &quot;OpenDocument Text (.odt)&quot;},&#10;&#9;&#9;{&quot;application/vnd.oasis.opendocument.spreadsheet&quot;, &quot;OpenDocument Spreadsheet (.ods)&quot;},&#10;&#9;&#9;{&quot;application/vnd.oasis.opendocument.presentation&quot;, &quot;OpenDocument Presentation (.odp)&quot;},&#10;&#9;&#9;{&quot;application/rtf&quot;, &quot;Rich Text Format (.rtf)&quot;},&#10;&#9;&#9;{&quot;text/html&quot;, &quot;HTML (.html)&quot;},&#10;&#9;&#9;{&quot;application/pdf&quot;, &quot;PDF (.pdf) - не требует конвертации&quot;},&#10;&#9;&#9;{&quot;image/jpeg&quot;, &quot;JPEG (.jpg) - не поддерживается&quot;},&#10;&#9;}&#10;&#10;&#9;fmt.Println(&quot;Поддержка конвертации в PDF:&quot;)&#10;&#9;fmt.Println(&quot;============================&quot;)&#10;&#10;&#9;for _, t := range supportedTypes {&#10;&#9;&#9;supported := docService.isConvertibleToPDF(t.mimeType)&#10;&#9;&#9;isOffice := docService.isOfficeDocument(t.mimeType)&#10;&#10;&#9;&#9;status := &quot;✗&quot;&#10;&#9;&#9;if supported {&#10;&#9;&#9;&#9;status = &quot;✓&quot;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;typeInfo := &quot;&quot;&#10;&#9;&#9;if isOffice {&#10;&#9;&#9;&#9;typeInfo = &quot; (Office/LibreOffice)&quot;&#10;&#9;&#9;}&#10;&#10;&#9;&#9;fmt.Printf(&quot;%s %s%s\n&quot;, status, t.description, typeInfo)&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/pkg/gotenberg/README.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/pkg/gotenberg/README.md" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="# Gotenberg Go Client&#10;&#10;Полнофункциональная библиотека на Go для работы с [Gotenberg API](https://gotenberg.dev) - сервисом для конвертации документов в PDF и создания скриншотов.&#10;&#10;## Установка&#10;&#10;```bash&#10;# Библиотека является частью проекта techmind&#10;import &quot;techmind/pkg/gotenberg&quot;&#10;```&#10;&#10;## Быстрый старт&#10;&#10;```go&#10;package main&#10;&#10;import (&#10;    &quot;context&quot;&#10;    &quot;os&quot;&#10;    &#10;    &quot;techmind/pkg/gotenberg&quot;&#10;)&#10;&#10;func main() {&#10;    // Создание клиента&#10;    client := gotenberg.NewClient(&quot;http://localhost:3000&quot;)&#10;    &#10;    // Конвертация URL в PDF&#10;    resp, err := client.ConvertURLToPDF(&#10;        context.Background(),&#10;        &quot;https://example.com&quot;,&#10;        &amp;gotenberg.ChromiumRequest{&#10;            PrintBackground: true,&#10;            OutputFilename:  &quot;example&quot;,&#10;        },&#10;    )&#10;    if err != nil {&#10;        panic(err)&#10;    }&#10;    &#10;    // Сохранение результата&#10;    os.WriteFile(&quot;example.pdf&quot;, resp.Body, 0644)&#10;}&#10;```&#10;&#10;## Возможности&#10;&#10;### Конвертация с помощью Chromium&#10;&#10;#### Конвертация URL в PDF&#10;&#10;```go&#10;resp, err := client.ConvertURLToPDF(ctx, &quot;https://example.com&quot;, &amp;gotenberg.ChromiumRequest{&#10;    PaperWidth:      &quot;8.5&quot;,&#10;    PaperHeight:     &quot;11&quot;,&#10;    MarginTop:       &quot;0.5&quot;,&#10;    MarginBottom:    &quot;0.5&quot;,&#10;    MarginLeft:      &quot;0.5&quot;,&#10;    MarginRight:     &quot;0.5&quot;,&#10;    PrintBackground: true,&#10;    Landscape:       false,&#10;    Scale:           1.0,&#10;})&#10;```&#10;&#10;#### Конвертация HTML в PDF&#10;&#10;```go&#10;htmlContent := []byte(`&lt;!DOCTYPE html&gt;&#10;&lt;html&gt;&#10;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&#10;&lt;body&gt;&lt;h1&gt;Hello!&lt;/h1&gt;&lt;/body&gt;&#10;&lt;/html&gt;`)&#10;&#10;resp, err := client.ConvertHTMLToPDF(&#10;    ctx,&#10;    gotenberg.File{Name: &quot;index.html&quot;, Content: htmlContent},&#10;    nil, // дополнительные файлы (CSS, изображения и т.д.)&#10;    &amp;gotenberg.ChromiumRequest{&#10;        PrintBackground: true,&#10;    },&#10;)&#10;```&#10;&#10;#### Конвертация Markdown в PDF&#10;&#10;```go&#10;htmlWrapper := []byte(`&lt;!DOCTYPE html&gt;&#10;&lt;html&gt;&#10;&lt;body&gt;{{ toHTML &quot;content.md&quot; }}&lt;/body&gt;&#10;&lt;/html&gt;`)&#10;&#10;markdownContent := []byte(`# Hello from Markdown!`)&#10;&#10;resp, err := client.ConvertMarkdownToPDF(&#10;    ctx,&#10;    gotenberg.File{Name: &quot;index.html&quot;, Content: htmlWrapper},&#10;    []gotenberg.File{{Name: &quot;content.md&quot;, Content: markdownContent}},&#10;    nil, // дополнительные файлы&#10;    nil, // опции&#10;)&#10;```&#10;&#10;### Создание скриншотов&#10;&#10;```go&#10;resp, err := client.ScreenshotURL(ctx, &quot;https://example.com&quot;, &amp;gotenberg.ScreenshotRequest{&#10;    Width:            1920,&#10;    Height:           1080,&#10;    Format:           &quot;png&quot;, // &quot;png&quot;, &quot;jpeg&quot;, &quot;webp&quot;&#10;    Quality:          100,   // для JPEG&#10;    OptimizeForSpeed: true,&#10;})&#10;```&#10;&#10;### Конвертация Office документов&#10;&#10;```go&#10;docxContent, _ := os.ReadFile(&quot;document.docx&quot;)&#10;&#10;resp, err := client.ConvertOfficeToPDF(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;document.docx&quot;, Content: docxContent}},&#10;    &amp;gotenberg.LibreOfficeRequest{&#10;        Landscape:        false,&#10;        NativePageRanges: &quot;1-5&quot;,&#10;        Merge:            false,&#10;    },&#10;)&#10;```&#10;&#10;Поддерживаемые форматы:&#10;- Word: `.doc`, `.docx`, `.dot`, `.dotx`, `.docm`, `.dotm`&#10;- Excel: `.xls`, `.xlsx`, `.xlsm`, `.xlt`, `.xltx`, `.xltm`&#10;- PowerPoint: `.ppt`, `.pptx`, `.pptm`, `.pot`, `.potx`, `.potm`&#10;- И многие другие (более 100 форматов)&#10;&#10;### Работа с PDF&#10;&#10;#### Объединение PDF&#10;&#10;```go&#10;pdf1, _ := os.ReadFile(&quot;doc1.pdf&quot;)&#10;pdf2, _ := os.ReadFile(&quot;doc2.pdf&quot;)&#10;&#10;resp, err := client.MergePDFs(&#10;    ctx,&#10;    []gotenberg.File{&#10;        {Name: &quot;doc1.pdf&quot;, Content: pdf1},&#10;        {Name: &quot;doc2.pdf&quot;, Content: pdf2},&#10;    },&#10;    &amp;gotenberg.PDFEnginesRequest{&#10;        PDFA: &quot;PDF/A-1b&quot;, // опционально&#10;    },&#10;)&#10;```&#10;&#10;#### Разделение PDF&#10;&#10;```go&#10;pdfContent, _ := os.ReadFile(&quot;multi-page.pdf&quot;)&#10;&#10;// По интервалам&#10;resp, err := client.SplitPDFs(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;multi-page.pdf&quot;, Content: pdfContent}},&#10;    &amp;gotenberg.SplitRequest{&#10;        SplitMode: &quot;intervals&quot;,&#10;        SplitSpan: &quot;2&quot;, // каждые 2 страницы&#10;    },&#10;)&#10;&#10;// По диапазонам страниц&#10;resp, err := client.SplitPDFs(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;multi-page.pdf&quot;, Content: pdfContent}},&#10;    &amp;gotenberg.SplitRequest{&#10;        SplitMode:  &quot;pages&quot;,&#10;        SplitSpan:  &quot;1-3,5,8-10&quot;,&#10;        SplitUnify: true, // объединить в один файл&#10;    },&#10;)&#10;```&#10;&#10;#### Чтение и запись метаданных&#10;&#10;```go&#10;// Чтение метаданных&#10;metadata, err := client.ReadPDFMetadata(ctx, []gotenberg.File{&#10;    {Name: &quot;sample.pdf&quot;, Content: pdfContent},&#10;})&#10;&#10;// Запись метаданных&#10;newMetadata := map[string]interface{}{&#10;    &quot;Author&quot;:   &quot;John Doe&quot;,&#10;    &quot;Title&quot;:    &quot;My Document&quot;,&#10;    &quot;Subject&quot;:  &quot;Important&quot;,&#10;    &quot;Keywords&quot;: []string{&quot;pdf&quot;, &quot;metadata&quot;},&#10;}&#10;&#10;resp, err := client.WritePDFMetadata(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;sample.pdf&quot;, Content: pdfContent}},&#10;    newMetadata,&#10;    &quot;output&quot;,&#10;)&#10;```&#10;&#10;#### Конвертация в PDF/A и PDF/UA&#10;&#10;```go&#10;resp, err := client.ConvertToPDFA(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;document.pdf&quot;, Content: pdfContent}},&#10;    &quot;PDF/A-1b&quot;, // &quot;PDF/A-1b&quot;, &quot;PDF/A-2b&quot;, &quot;PDF/A-3b&quot;&#10;    true,       // PDF/UA для доступности&#10;    &quot;output&quot;,&#10;)&#10;```&#10;&#10;#### Сглаживание PDF&#10;&#10;```go&#10;resp, err := client.FlattenPDFs(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;with-forms.pdf&quot;, Content: pdfContent}},&#10;    &quot;flattened&quot;,&#10;)&#10;```&#10;&#10;#### Шифрование PDF&#10;&#10;```go&#10;resp, err := client.EncryptPDFs(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;document.pdf&quot;, Content: pdfContent}},&#10;    &quot;user_password&quot;,  // пароль для открытия&#10;    &quot;owner_password&quot;, // пароль для полного доступа&#10;    &quot;encrypted&quot;,&#10;)&#10;```&#10;&#10;#### Встраивание файлов в PDF&#10;&#10;```go&#10;xmlContent, _ := os.ReadFile(&quot;invoice.xml&quot;)&#10;&#10;resp, err := client.EmbedFilesInPDF(&#10;    ctx,&#10;    []gotenberg.File{{Name: &quot;invoice.pdf&quot;, Content: pdfContent}},&#10;    []gotenberg.File{{Name: &quot;invoice.xml&quot;, Content: xmlContent}},&#10;    &quot;with-attachments&quot;,&#10;)&#10;```&#10;&#10;## Продвинутые возможности&#10;&#10;### Настройка страницы&#10;&#10;```go&#10;req := &amp;gotenberg.ChromiumRequest{&#10;    // Размер бумаги&#10;    PaperWidth:  &quot;8.27&quot;, // A4 ширина в дюймах&#10;    PaperHeight: &quot;11.7&quot;, // A4 высота в дюймах&#10;    &#10;    // Поля (в дюймах, можно использовать: pt, px, in, mm, cm, pc)&#10;    MarginTop:    &quot;1in&quot;,&#10;    MarginBottom: &quot;1in&quot;,&#10;    MarginLeft:   &quot;1in&quot;,&#10;    MarginRight:  &quot;1in&quot;,&#10;    &#10;    // Ориентация&#10;    Landscape: false,&#10;    &#10;    // Масштаб&#10;    Scale: 1.0,&#10;    &#10;    // Диапазон страниц&#10;    NativePageRanges: &quot;1-5,8,11-13&quot;,&#10;    &#10;    // Одна страница&#10;    SinglePage: false,&#10;    &#10;    // Предпочитать CSS размер&#10;    PreferCSSPageSize: false,&#10;    &#10;    // Фон&#10;    PrintBackground: true,&#10;    OmitBackground:  false, // прозрачный фон&#10;}&#10;```&#10;&#10;### Заголовки и подвалы&#10;&#10;```go&#10;headerHTML := []byte(`&#10;&lt;html&gt;&#10;&lt;head&gt;&#10;    &lt;style&gt;&#10;        body { font-size: 12px; text-align: center; }&#10;    &lt;/style&gt;&#10;&lt;/head&gt;&#10;&lt;body&gt;&#10;    &lt;p&gt;Страница &lt;span class=&quot;pageNumber&quot;&gt;&lt;/span&gt; из &lt;span class=&quot;totalPages&quot;&gt;&lt;/span&gt;&lt;/p&gt;&#10;&lt;/body&gt;&#10;&lt;/html&gt;&#10;`)&#10;&#10;req := &amp;gotenberg.ChromiumRequest{&#10;    Header: &amp;gotenberg.File{Name: &quot;header.html&quot;, Content: headerHTML},&#10;    Footer: &amp;gotenberg.File{Name: &quot;footer.html&quot;, Content: footerHTML},&#10;}&#10;```&#10;&#10;Доступные классы:&#10;- `.pageNumber` - текущий номер страницы&#10;- `.totalPages` - всего страниц&#10;- `.date` - дата печати&#10;- `.title` - заголовок документа&#10;- `.url` - URL документа&#10;&#10;### Ожидание перед рендерингом&#10;&#10;```go&#10;req := &amp;gotenberg.ChromiumRequest{&#10;    // Ждать 5 секунд&#10;    WaitDelay: &quot;5s&quot;,&#10;    &#10;    // Или ждать выполнения JavaScript выражения&#10;    WaitForExpression: &quot;window.status === 'ready'&quot;,&#10;}&#10;```&#10;&#10;### Cookies и HTTP заголовки&#10;&#10;```go&#10;req := &amp;gotenberg.ChromiumRequest{&#10;    // Cookies&#10;    Cookies: []gotenberg.Cookie{&#10;        {&#10;            Name:     &quot;session_id&quot;,&#10;            Value:    &quot;abc123&quot;,&#10;            Domain:   &quot;example.com&quot;,&#10;            Path:     &quot;/&quot;,&#10;            Secure:   true,&#10;            HTTPOnly: true,&#10;            SameSite: &quot;Strict&quot;,&#10;        },&#10;    },&#10;    &#10;    // User Agent&#10;    UserAgent: &quot;Mozilla/5.0 (Custom Agent)&quot;,&#10;    &#10;    // Дополнительные заголовки&#10;    ExtraHTTPHeaders: map[string]string{&#10;        &quot;Authorization&quot;: &quot;Bearer token&quot;,&#10;        &quot;X-Custom&quot;:      &quot;value&quot;,&#10;    },&#10;}&#10;```&#10;&#10;### Обработка ошибок&#10;&#10;```go&#10;req := &amp;gotenberg.ChromiumRequest{&#10;    // Ошибка при определенных HTTP статусах&#10;    FailOnHTTPStatusCodes: []int{499, 599}, // 400-499, 500-599&#10;    FailOnResourceHTTPStatusCodes: []int{499},&#10;    &#10;    // Ошибка при неудачной загрузке ресурсов&#10;    FailOnResourceLoadingFailed: true,&#10;    &#10;    // Ошибка при исключениях в консоли&#10;    FailOnConsoleExceptions: true,&#10;}&#10;```&#10;&#10;### Режим производительности&#10;&#10;```go&#10;req := &amp;gotenberg.ChromiumRequest{&#10;    // Не ждать события &quot;network idle&quot; для ускорения&#10;    SkipNetworkIdleEvent: true, // по умолчанию true&#10;}&#10;```&#10;&#10;### Загрузка файлов из URL&#10;&#10;```go&#10;req := &amp;gotenberg.ChromiumRequest{&#10;    DownloadFrom: []gotenberg.DownloadFrom{&#10;        {&#10;            URL: &quot;https://example.com/document.pdf&quot;,&#10;            ExtraHTTPHeaders: map[string]string{&#10;                &quot;Authorization&quot;: &quot;Bearer token&quot;,&#10;            },&#10;            Embedded: false, // встроить в результирующий PDF&#10;        },&#10;    },&#10;}&#10;```&#10;&#10;## Конфигурация клиента&#10;&#10;### Опции клиента&#10;&#10;```go&#10;import &quot;net/http&quot;&#10;import &quot;time&quot;&#10;&#10;client := gotenberg.NewClient(&#10;    &quot;http://localhost:3000&quot;,&#10;    &#10;    // Пользовательский HTTP клиент&#10;    gotenberg.WithHTTPClient(&amp;http.Client{&#10;        Timeout: 60 * time.Second,&#10;    }),&#10;    &#10;    // Trace ID для всех запросов&#10;    gotenberg.WithTrace(&quot;my-trace-id&quot;),&#10;)&#10;```&#10;&#10;### Health Check&#10;&#10;```go&#10;health, err := client.GetHealth(ctx)&#10;if err != nil {&#10;    log.Fatal(err)&#10;}&#10;&#10;fmt.Printf(&quot;Status: %s\n&quot;, health.Status)&#10;for name, check := range health.Details {&#10;    fmt.Printf(&quot;  %s: %s\n&quot;, name, check.Status)&#10;}&#10;```&#10;&#10;### Версия&#10;&#10;```go&#10;version, err := client.GetVersion(ctx)&#10;if err != nil {&#10;    log.Fatal(err)&#10;}&#10;fmt.Printf(&quot;Gotenberg version: %s\n&quot;, version)&#10;```&#10;&#10;## Структура Response&#10;&#10;```go&#10;type Response struct {&#10;    Body        []byte  // Содержимое файла&#10;    ContentType string  // MIME тип&#10;    Filename    string  // Имя файла из заголовка&#10;    Trace       string  // Trace ID запроса&#10;}&#10;```&#10;&#10;## Форматы PDF/A&#10;&#10;- `PDF/A-1b` - базовый уровень PDF/A-1&#10;- `PDF/A-2b` - базовый уровень PDF/A-2&#10;- `PDF/A-3b` - базовый уровень PDF/A-3 (с поддержкой встраивания файлов)&#10;&#10;## Обработка ошибок&#10;&#10;Все методы возвращают ошибку при:&#10;- Проблемах с сетью&#10;- HTTP статусах &gt;= 400&#10;- Невалидных параметрах&#10;&#10;```go&#10;resp, err := client.ConvertURLToPDF(ctx, url, req)&#10;if err != nil {&#10;    // Обработка ошибки&#10;    log.Printf(&quot;Failed to convert: %v&quot;, err)&#10;    return&#10;}&#10;&#10;// Использование результата&#10;os.WriteFile(&quot;output.pdf&quot;, resp.Body, 0644)&#10;```&#10;&#10;## Примеры&#10;&#10;Дополнительные примеры использования смотрите в файле [examples_test.go](examples_test.go).&#10;&#10;## Поддерживаемые форматы Office документов&#10;&#10;LibreOffice поддерживает конвертацию из более чем 100 форматов:&#10;&#10;**Документы:**&#10;- Word: `.doc`, `.docx`, `.dot`, `.dotx`, `.docm`, `.dotm`, `.rtf`&#10;- OpenDocument: `.odt`, `.ott`, `.fodt`&#10;- Другие: `.wpd`, `.wps`, `.abw`, `.zabw`&#10;&#10;**Таблицы:**&#10;- Excel: `.xls`, `.xlsx`, `.xlsm`, `.xlt`, `.xltx`, `.xltm`&#10;- OpenDocument: `.ods`, `.ots`, `.fods`&#10;- Другие: `.csv`, `.dbf`, `.slk`&#10;&#10;**Презентации:**&#10;- PowerPoint: `.ppt`, `.pptx`, `.pptm`, `.pot`, `.potx`, `.potm`&#10;- OpenDocument: `.odp`, `.otp`, `.fodp`&#10;- Другие: `.key`, `.pps`&#10;&#10;**Изображения:**&#10;- `.bmp`, `.gif`, `.jpeg`, `.jpg`, `.png`, `.svg`, `.tiff`, `.webp`&#10;&#10;И многие другие форматы.&#10;&#10;## Лицензия&#10;&#10;MIT&#10;&#10;## Ссылки&#10;&#10;- [Официальная документация Gotenberg](https://gotenberg.dev)&#10;- [Gotenberg на GitHub](https://github.com/gotenberg/gotenberg)&#10;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/company.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/company.go" />
              <option name="originalContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Company holds the schema definition for the Company entity.&#10;type Company struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Company.&#10;func (Company) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Company.&#10;func (Company) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.To(&quot;company_users&quot;, CompanyUser.Type),&#10;&#9;&#9;edge.To(&quot;folders&quot;, Folder.Type),&#10;&#9;&#9;edge.To(&quot;documents&quot;, Document.Type),&#10;&#9;&#9;edge.To(&quot;tags&quot;, Tag.Type),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Company holds the schema definition for the Company entity.&#10;type Company struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Company.&#10;func (Company) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Company.&#10;func (Company) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.To(&quot;company_users&quot;, CompanyUser.Type),&#10;&#9;&#9;edge.To(&quot;folders&quot;, Folder.Type),&#10;&#9;&#9;edge.To(&quot;documents&quot;, Document.Type),&#10;&#9;&#9;edge.To(&quot;tags&quot;, Tag.Type),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/document_tag.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/document_tag.go" />
              <option name="originalContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// DocumentTag holds the schema definition for the DocumentTag entity.&#10;type DocumentTag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the DocumentTag.&#10;func (DocumentTag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;document_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.UUID(&quot;tag_id&quot;, uuid.UUID{}),&#10;&#9;}&#10;}&#10;&#10;// Edges of the DocumentTag.&#10;func (DocumentTag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;document&quot;, Document.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;&#9;edge.From(&quot;tag&quot;, Tag.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// DocumentTag holds the schema definition for the DocumentTag entity.&#10;type DocumentTag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the DocumentTag.&#10;func (DocumentTag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;document_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.UUID(&quot;tag_id&quot;, uuid.UUID{}),&#10;&#9;}&#10;}&#10;&#10;// Edges of the DocumentTag.&#10;func (DocumentTag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;document&quot;, Document.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;&#9;edge.From(&quot;tag&quot;, Tag.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/homework_code_test.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/homework_code_test.go" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// HomeworkCodeTest holds the schema definition for the HomeworkCodeTest entity.&#10;type HomeworkCodeTest struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the HomeworkCodeTest.&#10;func (HomeworkCodeTest) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;task_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.String(&quot;in&quot;),&#10;&#9;&#9;field.String(&quot;out&quot;),&#10;&#9;&#9;field.Bool(&quot;is_hide&quot;).&#10;&#9;&#9;&#9;Default(false),&#10;&#9;}&#10;}&#10;&#10;// Edges of the HomeworkCodeTest.&#10;func (HomeworkCodeTest) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;task&quot;, HomeworkTask.Type).&#10;&#9;&#9;&#9;Ref(&quot;code_tests_rel&quot;).&#10;&#9;&#9;&#9;Field(&quot;task_id&quot;).&#10;&#9;&#9;&#9;Unique().&#10;&#9;&#9;&#9;Required(),&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/tag.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/tag.go" />
              <option name="originalContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Tag holds the schema definition for the Tag entity.&#10;type Tag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Tag.&#10;func (Tag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;company_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Tag.&#10;func (Tag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;company&quot;, Company.Type).&#10;&#9;&#9;&#9;Ref(&quot;tags&quot;).&#10;&#9;&#9;&#9;Field(&quot;company_id&quot;).&#10;&#9;&#9;&#9;Required().&#10;&#9;&#9;&#9;Unique(),&#10;&#9;&#9;edge.To(&quot;document_tags&quot;, DocumentTag.Type),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Tag holds the schema definition for the Tag entity.&#10;type Tag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Tag.&#10;func (Tag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;company_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Tag.&#10;func (Tag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;company&quot;, Company.Type).&#10;&#9;&#9;&#9;Ref(&quot;tags&quot;).&#10;&#9;&#9;&#9;Field(&quot;company_id&quot;).&#10;&#9;&#9;&#9;Required().&#10;&#9;&#9;&#9;Unique(),&#10;&#9;&#9;edge.To(&quot;document_tags&quot;, DocumentTag.Type),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/Dockerfile">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/Dockerfile" />
              <option name="originalContent" value="# Dockerfile for Next.js frontend&#10;FROM node:22.21.1-alpine AS base&#10;&#10;# Ensure pnpm is available in the base image&#10;RUN corepack enable &amp;&amp; corepack prepare pnpm@latest --activate&#10;&#10;# Build stage: install runtime compat, install deps and build the app&#10;FROM base AS builder&#10;RUN apk add --no-cache libc6-compat&#10;WORKDIR /app&#10;&#10;# copy lockfile(s) and package manifest first for better layer caching&#10;COPY package.json pnpm-lock.yaml* package-lock.json* ./&#10;RUN pnpm install&#10;&#10;# copy source and build&#10;COPY . .&#10;ENV NEXT_TELEMETRY_DISABLED 1&#10;RUN pnpm run build&#10;&#10;# Production image, copy only runtime artifacts and run&#10;FROM base AS runner&#10;WORKDIR /app&#10;&#10;ENV NODE_ENV=production&#10;ENV NEXT_TELEMETRY_DISABLED=1&#10;&#10;RUN addgroup --system --gid 1001 nodejs &amp;&amp; adduser --system --uid 1001 nextjs&#10;&#10;# Automatically leverage output traces to reduce image size&#10;COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./&#10;COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static&#10;&#10;USER nextjs&#10;&#10;EXPOSE 3000&#10;&#10;ENV PORT=3000&#10;ENV HOSTNAME=&quot;0.0.0.0&quot;&#10;&#10;CMD [&quot;node&quot;, &quot;server.js&quot;]&#10;" />
              <option name="updatedContent" value="# Dockerfile for Next.js frontend&#10;FROM node:22.21.1-alpine AS base&#10;&#10;# Ensure pnpm is available in the base image&#10;RUN corepack enable &amp;&amp; corepack prepare pnpm@latest --activate&#10;&#10;# Build stage: install runtime compat, install deps and build the app&#10;FROM base AS builder&#10;RUN apk add --no-cache libc6-compat&#10;WORKDIR /app&#10;&#10;# copy lockfile(s) and package manifest first for better layer caching&#10;COPY package.json pnpm-lock.yaml* package-lock.json* ./&#10;RUN pnpm install&#10;&#10;# copy source and build&#10;COPY . .&#10;ENV NEXT_TELEMETRY_DISABLED 1&#10;RUN pnpm run build&#10;&#10;# Production image, copy only runtime artifacts and run&#10;FROM base AS runner&#10;WORKDIR /app&#10;&#10;ENV NODE_ENV=production&#10;ENV NEXT_TELEMETRY_DISABLED=1&#10;&#10;RUN addgroup --system --gid 1001 nodejs &amp;&amp; adduser --system --uid 1001 nextjs&#10;&#10;# Automatically leverage output traces to reduce image size&#10;COPY --from=builder --chown=nextjs:nodejs /app/.next/standalone ./&#10;COPY --from=builder --chown=nextjs:nodejs /app/.next/static ./.next/static&#10;COPY --from=builder --chown=nextjs:nodejs /app/public ./public&#10;&#10;USER nextjs&#10;&#10;EXPOSE 3000&#10;&#10;ENV PORT=3000&#10;ENV HOSTNAME=&quot;0.0.0.0&quot;&#10;&#10;CMD [&quot;node&quot;, &quot;server.js&quot;]&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/frontend/next.config.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/frontend/next.config.js" />
              <option name="originalContent" value="/** @type {import('next').NextConfig} */&#10;const nextConfig = {&#10;    async rewrites() {&#10;        return [&#10;            {&#10;                source: '/api/:path*',&#10;                destination: 'http://127.0.0.1:58080/api/v1/:path*',&#10;            },&#10;        ]&#10;    },&#10;    turbopack: {&#10;        root: process.cwd(),&#10;    }&#10;};&#10;&#10;module.exports = nextConfig;&#10;" />
              <option name="updatedContent" value="/** @type {import('next').NextConfig} */&#10;const nextConfig = {&#10;    output: 'standalone',&#10;    async rewrites() {&#10;        return [&#10;            {&#10;                source: '/api/:path*',&#10;                destination: 'http://127.0.0.1:58080/api/v1/:path*',&#10;            },&#10;        ]&#10;    },&#10;    turbopack: {&#10;        root: process.cwd(),&#10;    }&#10;};&#10;&#10;module.exports = nextConfig;&#13;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/docker-compose.dev.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/docker-compose.dev.yml" />
              <option name="originalContent" value="version: &quot;3&quot;&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:17.5&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    environment:&#10;      POSTGRES_USER: postgres&#10;      POSTGRES_PASSWORD: postgres&#10;    networks:&#10;      - shared_network&#10;&#10;  minio:&#10;    image: minio/minio:latest&#10;    ports:&#10;      - &quot;9000:9000&quot;&#10;      - &quot;9001:9001&quot;&#10;    environment:&#10;      MINIO_ROOT_USER: minioadmin&#10;      MINIO_ROOT_PASSWORD: minioadmin&#10;    command: server /data --console-address &quot;:9001&quot;&#10;    networks:&#10;      - shared_network&#10;&#10;  gotenberg:&#10;    image: gotenberg/gotenberg:8&#10;    ports:&#10;      - &quot;3030:3000&quot;&#10;    command:&#10;      - &quot;gotenberg&quot;&#10;      - &quot;--api-timeout=60s&quot;&#10;      - &quot;--log-level=info&quot;&#10;    networks:&#10;      - shared_network&#10;&#10;  elasticsearch:&#10;    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0&#10;    ports:&#10;      - &quot;9200:9200&quot;&#10;    environment:&#10;      - discovery.type=single-node&#10;      - xpack.security.enabled=true&#10;      - xpack.security.enrollment.enabled=true&#10;      - ELASTIC_PASSWORD=changeme&#10;      - xpack.security.http.ssl.enabled=false&#10;    ulimits:&#10;      memlock:&#10;        soft: -1&#10;        hard: -1&#10;    networks:&#10;      - shared_network&#10;&#10;  sajaridocd:&#10;    image: sajari/docd:latest&#10;    command: [&quot;/docd&quot;, &quot;-addr&quot;, &quot;:8888&quot;]&#10;    ports:&#10;      - &quot;8888:8888&quot;&#10;    networks:&#10;      - shared_network&#10;&#10;networks:&#10;  shared_network:&#10;    driver: bridge&#10;" />
              <option name="updatedContent" value="version: &quot;3&quot;&#10;&#10;services:&#10;  postgres:&#10;    image: postgres:17.5&#10;    ports:&#10;      - &quot;5432:5432&quot;&#10;    environment:&#10;      POSTGRES_USER: postgres&#10;      POSTGRES_PASSWORD: postgres&#10;    networks:&#10;      - shared_network&#10;&#10;  minio:&#10;    image: minio/minio:latest&#10;    ports:&#10;      - &quot;9000:9000&quot;&#10;      - &quot;9001:9001&quot;&#10;    environment:&#10;      MINIO_ROOT_USER: minioadmin&#10;      MINIO_ROOT_PASSWORD: minioadmin&#10;    command: server /data --console-address &quot;:9001&quot;&#10;    networks:&#10;      - shared_network&#10;&#10;  gotenberg:&#10;    image: gotenberg/gotenberg:8&#10;    ports:&#10;      - &quot;3030:3000&quot;&#10;    command:&#10;      - &quot;gotenberg&quot;&#10;      - &quot;--api-timeout=60s&quot;&#10;      - &quot;--log-level=info&quot;&#10;    networks:&#10;      - shared_network&#10;&#10;  elasticsearch:&#10;    image: docker.elastic.co/elasticsearch/elasticsearch:8.11.0&#10;    ports:&#10;      - &quot;9200:9200&quot;&#10;    environment:&#10;      - discovery.type=single-node&#10;      - xpack.security.enabled=true&#10;      - xpack.security.enrollment.enabled=true&#10;      - ELASTIC_PASSWORD=changeme&#10;      - xpack.security.http.ssl.enabled=false&#10;    ulimits:&#10;      memlock:&#10;        soft: -1&#10;        hard: -1&#10;    networks:&#10;      - shared_network&#10;&#10;  sajaridocd:&#10;    image: sajari/docd:latest&#10;    command: [&quot;/docd&quot;, &quot;-addr&quot;, &quot;:8888&quot;]&#10;    ports:&#10;      - &quot;8888:8888&quot;&#10;    networks:&#10;      - shared_network&#10;&#10;networks:&#10;  shared_network:&#10;    driver: bridge&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>