<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/apps/api/app/app.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/app/app.go" />
              <option name="originalContent" value="package app&#10;&#10;import (&#10;&#9;&quot;techmind/internal/connetions/elasticsearch&quot;&#10;&#9;&quot;techmind/internal/connetions/minio&quot;&#10;&#9;&quot;techmind/internal/connetions/postgres&quot;&#10;&#9;&quot;techmind/internal/di&quot;&#10;&#10;&#9;&quot;go.uber.org/fx&quot;&#10;)&#10;&#10;var App = fx.Options(&#10;&#9;fx.Provide(&#10;&#9;&#9;postgres.New,&#10;&#9;&#9;minio.New,&#10;&#9;&#9;elasticsearch.New,&#10;&#9;),&#10;&#9;di.Repository,&#10;&#9;di.Service,&#10;&#9;di.Transport,&#10;)&#10;" />
              <option name="updatedContent" value="package app&#10;&#10;import (&#10;&#9;&quot;techmind/internal/connetions/elasticsearch&quot;&#10;&#9;&quot;techmind/internal/connetions/minio&quot;&#10;&#9;&quot;techmind/internal/connetions/postgres&quot;&#10;&#9;&quot;techmind/internal/di&quot;&#10;&#10;&#9;&quot;go.uber.org/fx&quot;&#10;)&#10;&#10;var App = fx.Options(&#10;&#9;fx.Provide(&#10;&#9;&#9;postgres.New,&#10;&#9;&#9;minio.New,&#10;&#9;&#9;elasticsearch.New,&#10;&#9;),&#10;&#9;di.Repository,&#10;&#9;di.Service,&#10;&#9;di.Transport,&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/internal/service/company_user_service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/internal/service/company_user_service.go" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;techmind/internal/repo&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;type companyUserService struct {&#10;&#9;repo repo.CompanyUserRepository&#10;}&#10;&#10;func NewCompanyUserService(repo repo.CompanyUserRepository) CompanyUserService {&#10;&#9;return &amp;companyUserService{repo: repo}&#10;}&#10;&#10;func (s *companyUserService) GetUserRole(ctx context.Context, userID, companyID uuid.UUID) (int, error) {&#10;&#9;return s.repo.GetUserRole(ctx, userID, companyID)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/internal/service/service.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/internal/service/service.go" />
              <option name="originalContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;techmind/schema/ent&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// AuthService определяет интерфейс для работы с авторизацией и аутентификацией&#10;type AuthService interface {&#10;&#9;// Login выполняет вход пользователя в систему&#10;&#9;// Принимает email и пароль, возвращает JWT токен со сроком действия 72 часа&#10;&#9;Login(ctx context.Context, email, password string) (token string, expiresAt time.Time, err error)&#10;&#10;&#9;// Register регистрирует нового пользователя в системе&#10;&#9;// Создает пользователя и возвращает JWT токен для автоматического входа&#10;&#9;Register(ctx context.Context, name, email, password string) (token string, user *ent.User, err error)&#10;&#10;&#9;// ValidateToken проверяет валидность JWT токена&#10;&#9;// Возвращает ID пользователя если токен валиден&#10;&#9;ValidateToken(ctx context.Context, token string) (userID uuid.UUID, err error)&#10;}&#10;&#10;// FolderService определяет интерфейс для работы с папками&#10;type FolderService interface {&#10;&#9;// Create создает новую папку в компании&#10;&#9;// Если parentID указан, папка создается как подпапка&#10;&#9;Create(ctx context.Context, companyID uuid.UUID, name string, parentID *uuid.UUID) (*ent.Folder, error)&#10;&#10;&#9;// Delete удаляет папку по ID&#10;&#9;// Также удаляет все вложенные папки и документы&#10;&#9;Delete(ctx context.Context, folderID uuid.UUID) error&#10;&#10;&#9;// Rename переименовывает папку&#10;&#9;Rename(ctx context.Context, folderID uuid.UUID, newName string) (*ent.Folder, error)&#10;&#10;&#9;// GetByCompany получает список всех папок в компании&#10;&#9;// Возвращает все папки без учета иерархии&#10;&#9;GetByCompany(ctx context.Context, companyID uuid.UUID) ([]*ent.Folder, error)&#10;&#10;&#9;// GetByParent получает список папок по родительской папке&#10;&#9;// Если parentID nil, возвращает корневые папки компании&#10;&#9;GetByParent(ctx context.Context, companyID uuid.UUID, parentID *uuid.UUID) ([]*ent.Folder, error)&#10;&#10;&#9;// GetByID получает папку по ID&#10;&#9;GetByID(ctx context.Context, folderID uuid.UUID) (*ent.Folder, error)&#10;}&#10;&#10;// DocumentUploadInput содержит данные для загрузки документа&#10;type DocumentUploadInput struct {&#10;&#9;CompanyID uuid.UUID&#10;&#9;FolderID  *uuid.UUID&#10;&#9;Name      string&#10;&#9;File      io.Reader&#10;&#9;FileSize  int64&#10;&#9;MimeType  string&#10;&#9;SenderID  *uuid.UUID&#10;}&#10;&#10;// DocumentUpdateInput содержит данные для обновления метаданных документа&#10;type DocumentUpdateInput struct {&#10;&#9;Name     string&#10;&#9;FolderID *uuid.UUID&#10;&#9;SenderID *uuid.UUID&#10;}&#10;&#10;// DocumentWithTags содержит документ вместе с его тегами&#10;type DocumentWithTags struct {&#10;&#9;Document   *ent.Document&#10;&#9;Tags       []*ent.Tag&#10;&#9;PreviewURL string&#10;}&#10;&#10;// DocumentService определяет интерфейс для работы с документами&#10;type DocumentService interface {&#10;&#9;// Upload загружает новый документ в систему&#10;&#9;// Принимает файл, сохраняет его в MinIO и создает запись в БД&#10;&#9;// Генерирует preview для поддерживаемых типов файлов&#10;&#9;Upload(ctx context.Context, input DocumentUploadInput) (*ent.Document, error)&#10;&#10;&#9;// GetByID получает документ по ID вместе с его тегами&#10;&#9;// Возвращает ссылку на preview документа&#10;&#9;GetByID(ctx context.Context, documentID uuid.UUID) (*DocumentWithTags, error)&#10;&#10;&#9;// GetByFolder получает список документов в папке&#10;&#9;// Включает теги для каждого документа&#10;&#9;GetByFolder(ctx context.Context, folderID uuid.UUID) ([]*DocumentWithTags, error)&#10;&#10;&#9;// GetByCompany получает список всех документов компании&#10;&#9;GetByCompany(ctx context.Context, companyID uuid.UUID) ([]*DocumentWithTags, error)&#10;&#10;&#9;// Update обновляет метаданные документа&#10;&#9;// Позволяет изменить имя, папку и отправителя&#10;&#9;Update(ctx context.Context, documentID uuid.UUID, input DocumentUpdateInput) (*ent.Document, error)&#10;&#10;&#9;// Delete удаляет документ из системы&#10;&#9;// Удаляет файлы из MinIO и запись из БД&#10;&#9;Delete(ctx context.Context, documentID uuid.UUID) error&#10;&#10;&#9;// GetDownloadURL получает временную ссылку на скачивание оригинала документа&#10;&#9;// Возвращает presigned URL для доступа к файлу в MinIO&#10;&#9;GetDownloadURL(ctx context.Context, documentID uuid.UUID) (url string, err error)&#10;&#10;&#9;// GetPreviewURL получает временную ссылку на preview документа&#10;&#9;// Возвращает presigned URL для доступа к preview файлу&#10;&#9;GetPreviewURL(ctx context.Context, documentID uuid.UUID) (url string, err error)&#10;&#10;&#9;// Search ищет документы по различным критериям&#10;&#9;Search(ctx context.Context, companyID uuid.UUID, query string, folderID *uuid.UUID, tagIDs []uuid.UUID) ([]*DocumentWithTags, error)&#10;}&#10;&#10;// DocumentTagService определяет интерфейс для работы с тегами документов&#10;type DocumentTagService interface {&#10;&#9;// GetDocumentTags получает все теги конкретного документа&#10;&#9;GetDocumentTags(ctx context.Context, documentID uuid.UUID) ([]*ent.Tag, error)&#10;&#10;&#9;// AddTagToDocument добавляет существующий тег к документу&#10;&#9;AddTagToDocument(ctx context.Context, documentID, tagID uuid.UUID) error&#10;&#10;&#9;// RemoveTagFromDocument удаляет тег у документа&#10;&#9;RemoveTagFromDocument(ctx context.Context, documentID, tagID uuid.UUID) error&#10;&#10;&#9;// CreateTag создает новый тег в компании&#10;&#9;CreateTag(ctx context.Context, companyID uuid.UUID, name string) (*ent.Tag, error)&#10;&#10;&#9;// DeleteTag удаляет тег из системы&#10;&#9;// Также удаляет все связи этого тега с документами&#10;&#9;DeleteTag(ctx context.Context, tagID uuid.UUID) error&#10;&#10;&#9;// GetTagsByCompany получает все теги компании&#10;&#9;GetTagsByCompany(ctx context.Context, companyID uuid.UUID) ([]*ent.Tag, error)&#10;&#10;&#9;// GetTagByID получает тег по ID&#10;&#9;GetTagByID(ctx context.Context, tagID uuid.UUID) (*ent.Tag, error)&#10;&#10;&#9;// UpdateTag обновляет название тега&#10;&#9;UpdateTag(ctx context.Context, tagID uuid.UUID, name string) (*ent.Tag, error)&#10;}&#10;&#10;// CompanyUserService определяет интерфейс для работы с пользователями компании&#10;type CompanyUserService interface {&#10;&#9;// GetUserRole получает роль пользователя в конкретной компании&#10;&#9;GetUserRole(ctx context.Context, userID, companyID uuid.UUID) (int, error)&#10;&#10;&#9;// GetUserCompanies получает список всех компаний пользователя с информацией о ролях&#10;&#9;GetUserCompanies(ctx context.Context, userID uuid.UUID) ([]*ent.CompanyUser, error)&#10;}&#10;" />
              <option name="updatedContent" value="package service&#10;&#10;import (&#10;&#9;&quot;context&quot;&#10;&#9;&quot;io&quot;&#10;&#9;&quot;techmind/schema/ent&quot;&#10;&#9;&quot;time&quot;&#10;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// AuthService определяет интерфейс для работы с авторизацией и аутентификацией&#10;type AuthService interface {&#10;&#9;// Login выполняет вход пользователя в систему&#10;&#9;// Принимает email и пароль, возвращает JWT токен со сроком действия 72 часа&#10;&#9;Login(ctx context.Context, email, password string) (token string, expiresAt time.Time, err error)&#10;&#10;&#9;// Register регистрирует нового пользователя в системе&#10;&#9;// Создает пользователя и возвращает JWT токен для автоматического входа&#10;&#9;Register(ctx context.Context, name, email, password string) (token string, user *ent.User, err error)&#10;&#10;&#9;// ValidateToken проверяет валидность JWT токена&#10;&#9;// Возвращает ID пользователя если токен валиден&#10;&#9;ValidateToken(ctx context.Context, token string) (userID uuid.UUID, err error)&#10;}&#10;&#10;// FolderService определяет интерфейс для работы с папками&#10;type FolderService interface {&#10;&#9;// Create создает новую папку в компании&#10;&#9;// Если parentID указан, папка создается как подпапка&#10;&#9;Create(ctx context.Context, companyID uuid.UUID, name string, parentID *uuid.UUID) (*ent.Folder, error)&#10;&#10;&#9;// Delete удаляет папку по ID&#10;&#9;// Также удаляет все вложенные папки и документы&#10;&#9;Delete(ctx context.Context, folderID uuid.UUID) error&#10;&#10;&#9;// Rename переименовывает папку&#10;&#9;Rename(ctx context.Context, folderID uuid.UUID, newName string) (*ent.Folder, error)&#10;&#10;&#9;// GetByCompany получает список всех папок в компании&#10;&#9;// Возвращает все папки без учета иерархии&#10;&#9;GetByCompany(ctx context.Context, companyID uuid.UUID) ([]*ent.Folder, error)&#10;&#10;&#9;// GetByParent получает список папок по родительской папке&#10;&#9;// Если parentID nil, возвращает корневые папки компании&#10;&#9;GetByParent(ctx context.Context, companyID uuid.UUID, parentID *uuid.UUID) ([]*ent.Folder, error)&#10;&#10;&#9;// GetByID получает папку по ID&#10;&#9;GetByID(ctx context.Context, folderID uuid.UUID) (*ent.Folder, error)&#10;}&#10;&#10;// DocumentUploadInput содержит данные для загрузки документа&#10;type DocumentUploadInput struct {&#10;&#9;CompanyID uuid.UUID&#10;&#9;FolderID  *uuid.UUID&#10;&#9;Name      string&#10;&#9;File      io.Reader&#10;&#9;FileSize  int64&#10;&#9;MimeType  string&#10;&#9;SenderID  *uuid.UUID&#10;}&#10;&#10;// DocumentUpdateInput содержит данные для обновления метаданных документа&#10;type DocumentUpdateInput struct {&#10;&#9;Name     string&#10;&#9;FolderID *uuid.UUID&#10;&#9;SenderID *uuid.UUID&#10;}&#10;&#10;// DocumentWithTags содержит документ вместе с его тегами&#10;type DocumentWithTags struct {&#10;&#9;Document   *ent.Document&#10;&#9;Tags       []*ent.Tag&#10;&#9;PreviewURL string&#10;}&#10;&#10;// DocumentService определяет интерфейс для работы с документами&#10;type DocumentService interface {&#10;&#9;// Upload загружает новый документ в систему&#10;&#9;// Принимает файл, сохраняет его в MinIO и создает запись в БД&#10;&#9;// Генерирует preview для поддерживаемых типов файлов&#10;&#9;Upload(ctx context.Context, input DocumentUploadInput) (*ent.Document, error)&#10;&#10;&#9;// GetByID получает документ по ID вместе с его тегами&#10;&#9;// Возвращает ссылку на preview документа&#10;&#9;GetByID(ctx context.Context, documentID uuid.UUID) (*DocumentWithTags, error)&#10;&#10;&#9;// GetByFolder получает список документов в папке&#10;&#9;// Включает теги для каждого документа&#10;&#9;GetByFolder(ctx context.Context, folderID uuid.UUID) ([]*DocumentWithTags, error)&#10;&#10;&#9;// GetByCompany получает список всех документов компании&#10;&#9;GetByCompany(ctx context.Context, companyID uuid.UUID) ([]*DocumentWithTags, error)&#10;&#10;&#9;// Update обновляет метаданные документа&#10;&#9;// Позволяет изменить имя, папку и отправителя&#10;&#9;Update(ctx context.Context, documentID uuid.UUID, input DocumentUpdateInput) (*ent.Document, error)&#10;&#10;&#9;// Delete удаляет документ из системы&#10;&#9;// Удаляет файлы из MinIO и запись из БД&#10;&#9;Delete(ctx context.Context, documentID uuid.UUID) error&#10;&#10;&#9;// GetDownloadURL получает временную ссылку на скачивание оригинала документа&#10;&#9;// Возвращает presigned URL для доступа к файлу в MinIO&#10;&#9;GetDownloadURL(ctx context.Context, documentID uuid.UUID) (url string, err error)&#10;&#10;&#9;// GetPreviewURL получает временную ссылку на preview документа&#10;&#9;// Возвращает presigned URL для доступа к preview файлу&#10;&#9;GetPreviewURL(ctx context.Context, documentID uuid.UUID) (url string, err error)&#10;&#10;&#9;// Search ищет документы по различным критериям&#10;&#9;Search(ctx context.Context, companyID uuid.UUID, query string, folderID *uuid.UUID, tagIDs []uuid.UUID) ([]*DocumentWithTags, error)&#10;}&#10;&#10;// DocumentTagService определяет интерфейс для работы с тегами документов&#10;type DocumentTagService interface {&#10;&#9;// GetDocumentTags получает все теги конкретного документа&#10;&#9;GetDocumentTags(ctx context.Context, documentID uuid.UUID) ([]*ent.Tag, error)&#10;&#10;&#9;// AddTagToDocument добавляет существующий тег к документу&#10;&#9;AddTagToDocument(ctx context.Context, documentID, tagID uuid.UUID) error&#10;&#10;&#9;// RemoveTagFromDocument удаляет тег у документа&#10;&#9;RemoveTagFromDocument(ctx context.Context, documentID, tagID uuid.UUID) error&#10;&#10;&#9;// CreateTag создает новый тег в компании&#10;&#9;CreateTag(ctx context.Context, companyID uuid.UUID, name string) (*ent.Tag, error)&#10;&#10;&#9;// DeleteTag удаляет тег из системы&#10;&#9;// Также удаляет все связи этого тега с документами&#10;&#9;DeleteTag(ctx context.Context, tagID uuid.UUID) error&#10;&#10;&#9;// GetTagsByCompany получает все теги компании&#10;&#9;GetTagsByCompany(ctx context.Context, companyID uuid.UUID) ([]*ent.Tag, error)&#10;&#10;&#9;// GetTagByID получает тег по ID&#10;&#9;GetTagByID(ctx context.Context, tagID uuid.UUID) (*ent.Tag, error)&#10;&#10;&#9;// UpdateTag обновляет название тега&#10;&#9;UpdateTag(ctx context.Context, tagID uuid.UUID, name string) (*ent.Tag, error)&#10;}&#10;&#10;// CompanyUserService определяет интерфейс для работы с пользователями компании&#10;type CompanyUserService interface {&#10;&#9;// GetUserRole получает роль пользователя в конкретной компании&#10;&#9;GetUserRole(ctx context.Context, userID, companyID uuid.UUID) (int, error)&#10;&#10;&#9;// GetUserCompanies получает список всех компаний пользователя с информацией о ролях&#10;&#9;GetUserCompanies(ctx context.Context, userID uuid.UUID) ([]*ent.CompanyUser, error)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/internal/transport/http/handlers/dto.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/internal/transport/http/handlers/dto.go" />
              <option name="originalContent" value="package handlers&#10;&#10;// ErrorResponse представляет ответ с ошибкой&#10;type ErrorResponse struct {&#10;&#9;Error string `json:&quot;error&quot; example:&quot;error message&quot;`&#10;}&#10;" />
              <option name="updatedContent" value="package handlers&#10;&#10;import (&#10;&#9;&quot;errors&quot;&#10;&#10;&#9;&quot;github.com/gofiber/fiber/v3&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;const UserIDContextKey = &quot;user_id&quot;&#10;const CompanyIDContextKey = &quot;company_id&quot;&#10;&#10;// GetUserIDFromContext извлекает user_id из контекста&#10;func GetUserIDFromContext(c fiber.Ctx) (uuid.UUID, error) {&#10;&#9;userID := c.Locals(UserIDContextKey)&#10;&#9;if userID == nil {&#10;&#9;&#9;return uuid.Nil, errors.New(&quot;user_id not found in context&quot;)&#10;&#9;}&#10;&#10;&#9;id, ok := userID.(uuid.UUID)&#10;&#9;if !ok {&#10;&#9;&#9;return uuid.Nil, errors.New(&quot;invalid user_id type in context&quot;)&#10;&#9;}&#10;&#10;&#9;return id, nil&#10;}&#10;&#10;// GetCompanyIDFromContext извлекает company_id из контекста&#10;func GetCompanyIDFromContext(c fiber.Ctx) (uuid.UUID, error) {&#10;&#9;companyID := c.Locals(CompanyIDContextKey)&#10;&#9;if companyID == nil {&#10;&#9;&#9;return uuid.Nil, errors.New(&quot;company_id not found in context&quot;)&#10;&#9;}&#10;&#10;&#9;id, ok := companyID.(uuid.UUID)&#10;&#9;if !ok {&#10;&#9;&#9;return uuid.Nil, errors.New(&quot;invalid company_id type in context&quot;)&#10;&#9;}&#10;&#10;&#9;return id, nil&#10;}&#10;&#10;// ErrorResponse представляет ответ с ошибкой&#10;type ErrorResponse struct {&#10;&#9;Error string `json:&quot;error&quot; example:&quot;error message&quot;`&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/company.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/company.go" />
              <option name="originalContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Company holds the schema definition for the Company entity.&#10;type Company struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Company.&#10;func (Company) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Company.&#10;func (Company) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.To(&quot;company_users&quot;, CompanyUser.Type),&#10;&#9;&#9;edge.To(&quot;folders&quot;, Folder.Type),&#10;&#9;&#9;edge.To(&quot;documents&quot;, Document.Type),&#10;&#9;&#9;edge.To(&quot;tags&quot;, Tag.Type),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Company holds the schema definition for the Company entity.&#10;type Company struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Company.&#10;func (Company) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Company.&#10;func (Company) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.To(&quot;company_users&quot;, CompanyUser.Type),&#10;&#9;&#9;edge.To(&quot;folders&quot;, Folder.Type),&#10;&#9;&#9;edge.To(&quot;documents&quot;, Document.Type),&#10;&#9;&#9;edge.To(&quot;tags&quot;, Tag.Type),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/document_tag.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/document_tag.go" />
              <option name="originalContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// DocumentTag holds the schema definition for the DocumentTag entity.&#10;type DocumentTag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the DocumentTag.&#10;func (DocumentTag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;document_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.UUID(&quot;tag_id&quot;, uuid.UUID{}),&#10;&#9;}&#10;}&#10;&#10;// Edges of the DocumentTag.&#10;func (DocumentTag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;document&quot;, Document.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;&#9;edge.From(&quot;tag&quot;, Tag.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// DocumentTag holds the schema definition for the DocumentTag entity.&#10;type DocumentTag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the DocumentTag.&#10;func (DocumentTag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;document_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.UUID(&quot;tag_id&quot;, uuid.UUID{}),&#10;&#9;}&#10;}&#10;&#10;// Edges of the DocumentTag.&#10;func (DocumentTag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;document&quot;, Document.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;&#9;edge.From(&quot;tag&quot;, Tag.Type).&#10;&#9;&#9;&#9;Ref(&quot;document_tags&quot;),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/homework_code_test.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/homework_code_test.go" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// HomeworkCodeTest holds the schema definition for the HomeworkCodeTest entity.&#10;type HomeworkCodeTest struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the HomeworkCodeTest.&#10;func (HomeworkCodeTest) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;task_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.String(&quot;in&quot;),&#10;&#9;&#9;field.String(&quot;out&quot;),&#10;&#9;&#9;field.Bool(&quot;is_hide&quot;).&#10;&#9;&#9;&#9;Default(false),&#10;&#9;}&#10;}&#10;&#10;// Edges of the HomeworkCodeTest.&#10;func (HomeworkCodeTest) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;task&quot;, HomeworkTask.Type).&#10;&#9;&#9;&#9;Ref(&quot;code_tests_rel&quot;).&#10;&#9;&#9;&#9;Field(&quot;task_id&quot;).&#10;&#9;&#9;&#9;Unique().&#10;&#9;&#9;&#9;Required(),&#10;&#9;}&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/apps/api/schema/tag.go">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/apps/api/schema/tag.go" />
              <option name="originalContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Tag holds the schema definition for the Tag entity.&#10;type Tag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Tag.&#10;func (Tag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;company_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Tag.&#10;func (Tag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;company&quot;, Company.Type).&#10;&#9;&#9;&#9;Ref(&quot;tags&quot;).&#10;&#9;&#9;&#9;Field(&quot;company_id&quot;).&#10;&#9;&#9;&#9;Required().&#10;&#9;&#9;&#9;Unique(),&#10;&#9;&#9;edge.To(&quot;document_tags&quot;, DocumentTag.Type),&#10;&#9;}&#10;}&#10;" />
              <option name="updatedContent" value="package schema&#10;&#10;import (&#10;&#9;&quot;entgo.io/ent&quot;&#10;&#9;&quot;entgo.io/ent/schema/edge&quot;&#10;&#9;&quot;entgo.io/ent/schema/field&quot;&#10;&#9;&quot;github.com/google/uuid&quot;&#10;)&#10;&#10;// Tag holds the schema definition for the Tag entity.&#10;type Tag struct {&#10;&#9;ent.Schema&#10;}&#10;&#10;// Fields of the Tag.&#10;func (Tag) Fields() []ent.Field {&#10;&#9;return []ent.Field{&#10;&#9;&#9;field.UUID(&quot;id&quot;, uuid.UUID{}).&#10;&#9;&#9;&#9;Default(uuid.New).&#10;&#9;&#9;&#9;Immutable(),&#10;&#9;&#9;field.UUID(&quot;company_id&quot;, uuid.UUID{}),&#10;&#9;&#9;field.String(&quot;name&quot;).&#10;&#9;&#9;&#9;NotEmpty(),&#10;&#9;}&#10;}&#10;&#10;// Edges of the Tag.&#10;func (Tag) Edges() []ent.Edge {&#10;&#9;return []ent.Edge{&#10;&#9;&#9;edge.From(&quot;company&quot;, Company.Type).&#10;&#9;&#9;&#9;Ref(&quot;tags&quot;).&#10;&#9;&#9;&#9;Field(&quot;company_id&quot;).&#10;&#9;&#9;&#9;Required().&#10;&#9;&#9;&#9;Unique(),&#10;&#9;&#9;edge.To(&quot;document_tags&quot;, DocumentTag.Type),&#10;&#9;}&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>