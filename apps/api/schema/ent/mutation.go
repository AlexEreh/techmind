// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"techmind/schema/ent/company"
	"techmind/schema/ent/companyuser"
	"techmind/schema/ent/document"
	"techmind/schema/ent/documenttag"
	"techmind/schema/ent/folder"
	"techmind/schema/ent/predicate"
	"techmind/schema/ent/sender"
	"techmind/schema/ent/tag"
	"techmind/schema/ent/user"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCompany     = "Company"
	TypeCompanyUser = "CompanyUser"
	TypeDocument    = "Document"
	TypeDocumentTag = "DocumentTag"
	TypeFolder      = "Folder"
	TypeSender      = "Sender"
	TypeTag         = "Tag"
	TypeUser        = "User"
)

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	clearedFields        map[string]struct{}
	company_users        map[uuid.UUID]struct{}
	removedcompany_users map[uuid.UUID]struct{}
	clearedcompany_users bool
	folders              map[uuid.UUID]struct{}
	removedfolders       map[uuid.UUID]struct{}
	clearedfolders       bool
	documents            map[uuid.UUID]struct{}
	removeddocuments     map[uuid.UUID]struct{}
	cleareddocuments     bool
	tags                 map[uuid.UUID]struct{}
	removedtags          map[uuid.UUID]struct{}
	clearedtags          bool
	done                 bool
	oldValue             func(context.Context) (*Company, error)
	predicates           []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id uuid.UUID) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Company entities.
func (m *CompanyMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Company.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// AddCompanyUserIDs adds the "company_users" edge to the CompanyUser entity by ids.
func (m *CompanyMutation) AddCompanyUserIDs(ids ...uuid.UUID) {
	if m.company_users == nil {
		m.company_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.company_users[ids[i]] = struct{}{}
	}
}

// ClearCompanyUsers clears the "company_users" edge to the CompanyUser entity.
func (m *CompanyMutation) ClearCompanyUsers() {
	m.clearedcompany_users = true
}

// CompanyUsersCleared reports if the "company_users" edge to the CompanyUser entity was cleared.
func (m *CompanyMutation) CompanyUsersCleared() bool {
	return m.clearedcompany_users
}

// RemoveCompanyUserIDs removes the "company_users" edge to the CompanyUser entity by IDs.
func (m *CompanyMutation) RemoveCompanyUserIDs(ids ...uuid.UUID) {
	if m.removedcompany_users == nil {
		m.removedcompany_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.company_users, ids[i])
		m.removedcompany_users[ids[i]] = struct{}{}
	}
}

// RemovedCompanyUsers returns the removed IDs of the "company_users" edge to the CompanyUser entity.
func (m *CompanyMutation) RemovedCompanyUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedcompany_users {
		ids = append(ids, id)
	}
	return
}

// CompanyUsersIDs returns the "company_users" edge IDs in the mutation.
func (m *CompanyMutation) CompanyUsersIDs() (ids []uuid.UUID) {
	for id := range m.company_users {
		ids = append(ids, id)
	}
	return
}

// ResetCompanyUsers resets all changes to the "company_users" edge.
func (m *CompanyMutation) ResetCompanyUsers() {
	m.company_users = nil
	m.clearedcompany_users = false
	m.removedcompany_users = nil
}

// AddFolderIDs adds the "folders" edge to the Folder entity by ids.
func (m *CompanyMutation) AddFolderIDs(ids ...uuid.UUID) {
	if m.folders == nil {
		m.folders = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.folders[ids[i]] = struct{}{}
	}
}

// ClearFolders clears the "folders" edge to the Folder entity.
func (m *CompanyMutation) ClearFolders() {
	m.clearedfolders = true
}

// FoldersCleared reports if the "folders" edge to the Folder entity was cleared.
func (m *CompanyMutation) FoldersCleared() bool {
	return m.clearedfolders
}

// RemoveFolderIDs removes the "folders" edge to the Folder entity by IDs.
func (m *CompanyMutation) RemoveFolderIDs(ids ...uuid.UUID) {
	if m.removedfolders == nil {
		m.removedfolders = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.folders, ids[i])
		m.removedfolders[ids[i]] = struct{}{}
	}
}

// RemovedFolders returns the removed IDs of the "folders" edge to the Folder entity.
func (m *CompanyMutation) RemovedFoldersIDs() (ids []uuid.UUID) {
	for id := range m.removedfolders {
		ids = append(ids, id)
	}
	return
}

// FoldersIDs returns the "folders" edge IDs in the mutation.
func (m *CompanyMutation) FoldersIDs() (ids []uuid.UUID) {
	for id := range m.folders {
		ids = append(ids, id)
	}
	return
}

// ResetFolders resets all changes to the "folders" edge.
func (m *CompanyMutation) ResetFolders() {
	m.folders = nil
	m.clearedfolders = false
	m.removedfolders = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *CompanyMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *CompanyMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *CompanyMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *CompanyMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *CompanyMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *CompanyMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *CompanyMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *CompanyMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tags == nil {
		m.tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *CompanyMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *CompanyMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *CompanyMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtags == nil {
		m.removedtags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *CompanyMutation) RemovedTagsIDs() (ids []uuid.UUID) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *CompanyMutation) TagsIDs() (ids []uuid.UUID) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *CompanyMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Company, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.company_users != nil {
		edges = append(edges, company.EdgeCompanyUsers)
	}
	if m.folders != nil {
		edges = append(edges, company.EdgeFolders)
	}
	if m.documents != nil {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.tags != nil {
		edges = append(edges, company.EdgeTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeCompanyUsers:
		ids := make([]ent.Value, 0, len(m.company_users))
		for id := range m.company_users {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFolders:
		ids := make([]ent.Value, 0, len(m.folders))
		for id := range m.folders {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcompany_users != nil {
		edges = append(edges, company.EdgeCompanyUsers)
	}
	if m.removedfolders != nil {
		edges = append(edges, company.EdgeFolders)
	}
	if m.removeddocuments != nil {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.removedtags != nil {
		edges = append(edges, company.EdgeTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeCompanyUsers:
		ids := make([]ent.Value, 0, len(m.removedcompany_users))
		for id := range m.removedcompany_users {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeFolders:
		ids := make([]ent.Value, 0, len(m.removedfolders))
		for id := range m.removedfolders {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcompany_users {
		edges = append(edges, company.EdgeCompanyUsers)
	}
	if m.clearedfolders {
		edges = append(edges, company.EdgeFolders)
	}
	if m.cleareddocuments {
		edges = append(edges, company.EdgeDocuments)
	}
	if m.clearedtags {
		edges = append(edges, company.EdgeTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeCompanyUsers:
		return m.clearedcompany_users
	case company.EdgeFolders:
		return m.clearedfolders
	case company.EdgeDocuments:
		return m.cleareddocuments
	case company.EdgeTags:
		return m.clearedtags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeCompanyUsers:
		m.ResetCompanyUsers()
		return nil
	case company.EdgeFolders:
		m.ResetFolders()
		return nil
	case company.EdgeDocuments:
		m.ResetDocuments()
		return nil
	case company.EdgeTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// CompanyUserMutation represents an operation that mutates the CompanyUser nodes in the graph.
type CompanyUserMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	role           *int
	addrole        *int
	clearedFields  map[string]struct{}
	user           *uuid.UUID
	cleareduser    bool
	company        *uuid.UUID
	clearedcompany bool
	done           bool
	oldValue       func(context.Context) (*CompanyUser, error)
	predicates     []predicate.CompanyUser
}

var _ ent.Mutation = (*CompanyUserMutation)(nil)

// companyuserOption allows management of the mutation configuration using functional options.
type companyuserOption func(*CompanyUserMutation)

// newCompanyUserMutation creates new mutation for the CompanyUser entity.
func newCompanyUserMutation(c config, op Op, opts ...companyuserOption) *CompanyUserMutation {
	m := &CompanyUserMutation{
		config:        c,
		op:            op,
		typ:           TypeCompanyUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyUserID sets the ID field of the mutation.
func withCompanyUserID(id uuid.UUID) companyuserOption {
	return func(m *CompanyUserMutation) {
		var (
			err   error
			once  sync.Once
			value *CompanyUser
		)
		m.oldValue = func(ctx context.Context) (*CompanyUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CompanyUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompanyUser sets the old CompanyUser of the mutation.
func withCompanyUser(node *CompanyUser) companyuserOption {
	return func(m *CompanyUserMutation) {
		m.oldValue = func(context.Context) (*CompanyUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CompanyUser entities.
func (m *CompanyUserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyUserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CompanyUserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CompanyUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *CompanyUserMutation) SetUserID(u uuid.UUID) {
	m.user = &u
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *CompanyUserMutation) UserID() (r uuid.UUID, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldUserID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *CompanyUserMutation) ResetUserID() {
	m.user = nil
}

// SetCompanyID sets the "company_id" field.
func (m *CompanyUserMutation) SetCompanyID(u uuid.UUID) {
	m.company = &u
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *CompanyUserMutation) CompanyID() (r uuid.UUID, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldCompanyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *CompanyUserMutation) ResetCompanyID() {
	m.company = nil
}

// SetRole sets the "role" field.
func (m *CompanyUserMutation) SetRole(i int) {
	m.role = &i
	m.addrole = nil
}

// Role returns the value of the "role" field in the mutation.
func (m *CompanyUserMutation) Role() (r int, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the CompanyUser entity.
// If the CompanyUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyUserMutation) OldRole(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// AddRole adds i to the "role" field.
func (m *CompanyUserMutation) AddRole(i int) {
	if m.addrole != nil {
		*m.addrole += i
	} else {
		m.addrole = &i
	}
}

// AddedRole returns the value that was added to the "role" field in this mutation.
func (m *CompanyUserMutation) AddedRole() (r int, exists bool) {
	v := m.addrole
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole resets all changes to the "role" field.
func (m *CompanyUserMutation) ResetRole() {
	m.role = nil
	m.addrole = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *CompanyUserMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[companyuser.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CompanyUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CompanyUserMutation) UserIDs() (ids []uuid.UUID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CompanyUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *CompanyUserMutation) ClearCompany() {
	m.clearedcompany = true
	m.clearedFields[companyuser.FieldCompanyID] = struct{}{}
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *CompanyUserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *CompanyUserMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *CompanyUserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// Where appends a list predicates to the CompanyUserMutation builder.
func (m *CompanyUserMutation) Where(ps ...predicate.CompanyUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CompanyUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CompanyUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CompanyUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CompanyUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CompanyUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CompanyUser).
func (m *CompanyUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyUserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user != nil {
		fields = append(fields, companyuser.FieldUserID)
	}
	if m.company != nil {
		fields = append(fields, companyuser.FieldCompanyID)
	}
	if m.role != nil {
		fields = append(fields, companyuser.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case companyuser.FieldUserID:
		return m.UserID()
	case companyuser.FieldCompanyID:
		return m.CompanyID()
	case companyuser.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case companyuser.FieldUserID:
		return m.OldUserID(ctx)
	case companyuser.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case companyuser.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown CompanyUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case companyuser.FieldUserID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case companyuser.FieldCompanyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case companyuser.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyUserMutation) AddedFields() []string {
	var fields []string
	if m.addrole != nil {
		fields = append(fields, companyuser.FieldRole)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyUserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case companyuser.FieldRole:
		return m.AddedRole()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case companyuser.FieldRole:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRole(v)
		return nil
	}
	return fmt.Errorf("unknown CompanyUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyUserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyUserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CompanyUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyUserMutation) ResetField(name string) error {
	switch name {
	case companyuser.FieldUserID:
		m.ResetUserID()
		return nil
	case companyuser.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case companyuser.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, companyuser.EdgeUser)
	}
	if m.company != nil {
		edges = append(edges, companyuser.EdgeCompany)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case companyuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case companyuser.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, companyuser.EdgeUser)
	}
	if m.clearedcompany {
		edges = append(edges, companyuser.EdgeCompany)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyUserMutation) EdgeCleared(name string) bool {
	switch name {
	case companyuser.EdgeUser:
		return m.cleareduser
	case companyuser.EdgeCompany:
		return m.clearedcompany
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyUserMutation) ClearEdge(name string) error {
	switch name {
	case companyuser.EdgeUser:
		m.ClearUser()
		return nil
	case companyuser.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyUserMutation) ResetEdge(name string) error {
	switch name {
	case companyuser.EdgeUser:
		m.ResetUser()
		return nil
	case companyuser.EdgeCompany:
		m.ResetCompany()
		return nil
	}
	return fmt.Errorf("unknown CompanyUser edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                     Op
	typ                    string
	id                     *uuid.UUID
	name                   *string
	file_path              *string
	preview_file_path      *string
	file_size              *int64
	addfile_size           *int64
	mime_type              *string
	checksum               *string
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	company                *uuid.UUID
	clearedcompany         bool
	folder                 *uuid.UUID
	clearedfolder          bool
	sender                 *uuid.UUID
	clearedsender          bool
	created_by_user        *uuid.UUID
	clearedcreated_by_user bool
	updated_by_user        *uuid.UUID
	clearedupdated_by_user bool
	document_tags          map[uuid.UUID]struct{}
	removeddocument_tags   map[uuid.UUID]struct{}
	cleareddocument_tags   bool
	done                   bool
	oldValue               func(context.Context) (*Document, error)
	predicates             []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id uuid.UUID) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Document entities.
func (m *DocumentMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *DocumentMutation) SetCompanyID(u uuid.UUID) {
	m.company = &u
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *DocumentMutation) CompanyID() (r uuid.UUID, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCompanyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *DocumentMutation) ResetCompanyID() {
	m.company = nil
}

// SetFolderID sets the "folder_id" field.
func (m *DocumentMutation) SetFolderID(u uuid.UUID) {
	m.folder = &u
}

// FolderID returns the value of the "folder_id" field in the mutation.
func (m *DocumentMutation) FolderID() (r uuid.UUID, exists bool) {
	v := m.folder
	if v == nil {
		return
	}
	return *v, true
}

// OldFolderID returns the old "folder_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldFolderID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolderID: %w", err)
	}
	return oldValue.FolderID, nil
}

// ClearFolderID clears the value of the "folder_id" field.
func (m *DocumentMutation) ClearFolderID() {
	m.folder = nil
	m.clearedFields[document.FieldFolderID] = struct{}{}
}

// FolderIDCleared returns if the "folder_id" field was cleared in this mutation.
func (m *DocumentMutation) FolderIDCleared() bool {
	_, ok := m.clearedFields[document.FieldFolderID]
	return ok
}

// ResetFolderID resets all changes to the "folder_id" field.
func (m *DocumentMutation) ResetFolderID() {
	m.folder = nil
	delete(m.clearedFields, document.FieldFolderID)
}

// SetName sets the "name" field.
func (m *DocumentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocumentMutation) ResetName() {
	m.name = nil
}

// SetFilePath sets the "file_path" field.
func (m *DocumentMutation) SetFilePath(s string) {
	m.file_path = &s
}

// FilePath returns the value of the "file_path" field in the mutation.
func (m *DocumentMutation) FilePath() (r string, exists bool) {
	v := m.file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldFilePath returns the old "file_path" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldFilePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilePath: %w", err)
	}
	return oldValue.FilePath, nil
}

// ResetFilePath resets all changes to the "file_path" field.
func (m *DocumentMutation) ResetFilePath() {
	m.file_path = nil
}

// SetPreviewFilePath sets the "preview_file_path" field.
func (m *DocumentMutation) SetPreviewFilePath(s string) {
	m.preview_file_path = &s
}

// PreviewFilePath returns the value of the "preview_file_path" field in the mutation.
func (m *DocumentMutation) PreviewFilePath() (r string, exists bool) {
	v := m.preview_file_path
	if v == nil {
		return
	}
	return *v, true
}

// OldPreviewFilePath returns the old "preview_file_path" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldPreviewFilePath(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPreviewFilePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPreviewFilePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPreviewFilePath: %w", err)
	}
	return oldValue.PreviewFilePath, nil
}

// ClearPreviewFilePath clears the value of the "preview_file_path" field.
func (m *DocumentMutation) ClearPreviewFilePath() {
	m.preview_file_path = nil
	m.clearedFields[document.FieldPreviewFilePath] = struct{}{}
}

// PreviewFilePathCleared returns if the "preview_file_path" field was cleared in this mutation.
func (m *DocumentMutation) PreviewFilePathCleared() bool {
	_, ok := m.clearedFields[document.FieldPreviewFilePath]
	return ok
}

// ResetPreviewFilePath resets all changes to the "preview_file_path" field.
func (m *DocumentMutation) ResetPreviewFilePath() {
	m.preview_file_path = nil
	delete(m.clearedFields, document.FieldPreviewFilePath)
}

// SetFileSize sets the "file_size" field.
func (m *DocumentMutation) SetFileSize(i int64) {
	m.file_size = &i
	m.addfile_size = nil
}

// FileSize returns the value of the "file_size" field in the mutation.
func (m *DocumentMutation) FileSize() (r int64, exists bool) {
	v := m.file_size
	if v == nil {
		return
	}
	return *v, true
}

// OldFileSize returns the old "file_size" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldFileSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileSize: %w", err)
	}
	return oldValue.FileSize, nil
}

// AddFileSize adds i to the "file_size" field.
func (m *DocumentMutation) AddFileSize(i int64) {
	if m.addfile_size != nil {
		*m.addfile_size += i
	} else {
		m.addfile_size = &i
	}
}

// AddedFileSize returns the value that was added to the "file_size" field in this mutation.
func (m *DocumentMutation) AddedFileSize() (r int64, exists bool) {
	v := m.addfile_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileSize resets all changes to the "file_size" field.
func (m *DocumentMutation) ResetFileSize() {
	m.file_size = nil
	m.addfile_size = nil
}

// SetMimeType sets the "mime_type" field.
func (m *DocumentMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *DocumentMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *DocumentMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetChecksum sets the "checksum" field.
func (m *DocumentMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *DocumentMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *DocumentMutation) ResetChecksum() {
	m.checksum = nil
}

// SetSenderID sets the "sender_id" field.
func (m *DocumentMutation) SetSenderID(u uuid.UUID) {
	m.sender = &u
}

// SenderID returns the value of the "sender_id" field in the mutation.
func (m *DocumentMutation) SenderID() (r uuid.UUID, exists bool) {
	v := m.sender
	if v == nil {
		return
	}
	return *v, true
}

// OldSenderID returns the old "sender_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldSenderID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSenderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSenderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSenderID: %w", err)
	}
	return oldValue.SenderID, nil
}

// ClearSenderID clears the value of the "sender_id" field.
func (m *DocumentMutation) ClearSenderID() {
	m.sender = nil
	m.clearedFields[document.FieldSenderID] = struct{}{}
}

// SenderIDCleared returns if the "sender_id" field was cleared in this mutation.
func (m *DocumentMutation) SenderIDCleared() bool {
	_, ok := m.clearedFields[document.FieldSenderID]
	return ok
}

// ResetSenderID resets all changes to the "sender_id" field.
func (m *DocumentMutation) ResetSenderID() {
	m.sender = nil
	delete(m.clearedFields, document.FieldSenderID)
}

// SetCreatedBy sets the "created_by" field.
func (m *DocumentMutation) SetCreatedBy(u uuid.UUID) {
	m.created_by_user = &u
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *DocumentMutation) CreatedBy() (r uuid.UUID, exists bool) {
	v := m.created_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *DocumentMutation) ClearCreatedBy() {
	m.created_by_user = nil
	m.clearedFields[document.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *DocumentMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[document.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *DocumentMutation) ResetCreatedBy() {
	m.created_by_user = nil
	delete(m.clearedFields, document.FieldCreatedBy)
}

// SetUpdatedBy sets the "updated_by" field.
func (m *DocumentMutation) SetUpdatedBy(u uuid.UUID) {
	m.updated_by_user = &u
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *DocumentMutation) UpdatedBy() (r uuid.UUID, exists bool) {
	v := m.updated_by_user
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldUpdatedBy(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *DocumentMutation) ClearUpdatedBy() {
	m.updated_by_user = nil
	m.clearedFields[document.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *DocumentMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[document.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *DocumentMutation) ResetUpdatedBy() {
	m.updated_by_user = nil
	delete(m.clearedFields, document.FieldUpdatedBy)
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *DocumentMutation) ClearCompany() {
	m.clearedcompany = true
	m.clearedFields[document.FieldCompanyID] = struct{}{}
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *DocumentMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *DocumentMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// ClearFolder clears the "folder" edge to the Folder entity.
func (m *DocumentMutation) ClearFolder() {
	m.clearedfolder = true
	m.clearedFields[document.FieldFolderID] = struct{}{}
}

// FolderCleared reports if the "folder" edge to the Folder entity was cleared.
func (m *DocumentMutation) FolderCleared() bool {
	return m.FolderIDCleared() || m.clearedfolder
}

// FolderIDs returns the "folder" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FolderID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) FolderIDs() (ids []uuid.UUID) {
	if id := m.folder; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFolder resets all changes to the "folder" edge.
func (m *DocumentMutation) ResetFolder() {
	m.folder = nil
	m.clearedfolder = false
}

// ClearSender clears the "sender" edge to the Sender entity.
func (m *DocumentMutation) ClearSender() {
	m.clearedsender = true
	m.clearedFields[document.FieldSenderID] = struct{}{}
}

// SenderCleared reports if the "sender" edge to the Sender entity was cleared.
func (m *DocumentMutation) SenderCleared() bool {
	return m.SenderIDCleared() || m.clearedsender
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) SenderIDs() (ids []uuid.UUID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *DocumentMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// SetCreatedByUserID sets the "created_by_user" edge to the User entity by id.
func (m *DocumentMutation) SetCreatedByUserID(id uuid.UUID) {
	m.created_by_user = &id
}

// ClearCreatedByUser clears the "created_by_user" edge to the User entity.
func (m *DocumentMutation) ClearCreatedByUser() {
	m.clearedcreated_by_user = true
	m.clearedFields[document.FieldCreatedBy] = struct{}{}
}

// CreatedByUserCleared reports if the "created_by_user" edge to the User entity was cleared.
func (m *DocumentMutation) CreatedByUserCleared() bool {
	return m.CreatedByCleared() || m.clearedcreated_by_user
}

// CreatedByUserID returns the "created_by_user" edge ID in the mutation.
func (m *DocumentMutation) CreatedByUserID() (id uuid.UUID, exists bool) {
	if m.created_by_user != nil {
		return *m.created_by_user, true
	}
	return
}

// CreatedByUserIDs returns the "created_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByUserID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) CreatedByUserIDs() (ids []uuid.UUID) {
	if id := m.created_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedByUser resets all changes to the "created_by_user" edge.
func (m *DocumentMutation) ResetCreatedByUser() {
	m.created_by_user = nil
	m.clearedcreated_by_user = false
}

// SetUpdatedByUserID sets the "updated_by_user" edge to the User entity by id.
func (m *DocumentMutation) SetUpdatedByUserID(id uuid.UUID) {
	m.updated_by_user = &id
}

// ClearUpdatedByUser clears the "updated_by_user" edge to the User entity.
func (m *DocumentMutation) ClearUpdatedByUser() {
	m.clearedupdated_by_user = true
	m.clearedFields[document.FieldUpdatedBy] = struct{}{}
}

// UpdatedByUserCleared reports if the "updated_by_user" edge to the User entity was cleared.
func (m *DocumentMutation) UpdatedByUserCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdated_by_user
}

// UpdatedByUserID returns the "updated_by_user" edge ID in the mutation.
func (m *DocumentMutation) UpdatedByUserID() (id uuid.UUID, exists bool) {
	if m.updated_by_user != nil {
		return *m.updated_by_user, true
	}
	return
}

// UpdatedByUserIDs returns the "updated_by_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdatedByUserID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) UpdatedByUserIDs() (ids []uuid.UUID) {
	if id := m.updated_by_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdatedByUser resets all changes to the "updated_by_user" edge.
func (m *DocumentMutation) ResetUpdatedByUser() {
	m.updated_by_user = nil
	m.clearedupdated_by_user = false
}

// AddDocumentTagIDs adds the "document_tags" edge to the DocumentTag entity by ids.
func (m *DocumentMutation) AddDocumentTagIDs(ids ...uuid.UUID) {
	if m.document_tags == nil {
		m.document_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document_tags[ids[i]] = struct{}{}
	}
}

// ClearDocumentTags clears the "document_tags" edge to the DocumentTag entity.
func (m *DocumentMutation) ClearDocumentTags() {
	m.cleareddocument_tags = true
}

// DocumentTagsCleared reports if the "document_tags" edge to the DocumentTag entity was cleared.
func (m *DocumentMutation) DocumentTagsCleared() bool {
	return m.cleareddocument_tags
}

// RemoveDocumentTagIDs removes the "document_tags" edge to the DocumentTag entity by IDs.
func (m *DocumentMutation) RemoveDocumentTagIDs(ids ...uuid.UUID) {
	if m.removeddocument_tags == nil {
		m.removeddocument_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document_tags, ids[i])
		m.removeddocument_tags[ids[i]] = struct{}{}
	}
}

// RemovedDocumentTags returns the removed IDs of the "document_tags" edge to the DocumentTag entity.
func (m *DocumentMutation) RemovedDocumentTagsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument_tags {
		ids = append(ids, id)
	}
	return
}

// DocumentTagsIDs returns the "document_tags" edge IDs in the mutation.
func (m *DocumentMutation) DocumentTagsIDs() (ids []uuid.UUID) {
	for id := range m.document_tags {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentTags resets all changes to the "document_tags" edge.
func (m *DocumentMutation) ResetDocumentTags() {
	m.document_tags = nil
	m.cleareddocument_tags = false
	m.removeddocument_tags = nil
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.company != nil {
		fields = append(fields, document.FieldCompanyID)
	}
	if m.folder != nil {
		fields = append(fields, document.FieldFolderID)
	}
	if m.name != nil {
		fields = append(fields, document.FieldName)
	}
	if m.file_path != nil {
		fields = append(fields, document.FieldFilePath)
	}
	if m.preview_file_path != nil {
		fields = append(fields, document.FieldPreviewFilePath)
	}
	if m.file_size != nil {
		fields = append(fields, document.FieldFileSize)
	}
	if m.mime_type != nil {
		fields = append(fields, document.FieldMimeType)
	}
	if m.checksum != nil {
		fields = append(fields, document.FieldChecksum)
	}
	if m.sender != nil {
		fields = append(fields, document.FieldSenderID)
	}
	if m.created_by_user != nil {
		fields = append(fields, document.FieldCreatedBy)
	}
	if m.updated_by_user != nil {
		fields = append(fields, document.FieldUpdatedBy)
	}
	if m.created_at != nil {
		fields = append(fields, document.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, document.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldCompanyID:
		return m.CompanyID()
	case document.FieldFolderID:
		return m.FolderID()
	case document.FieldName:
		return m.Name()
	case document.FieldFilePath:
		return m.FilePath()
	case document.FieldPreviewFilePath:
		return m.PreviewFilePath()
	case document.FieldFileSize:
		return m.FileSize()
	case document.FieldMimeType:
		return m.MimeType()
	case document.FieldChecksum:
		return m.Checksum()
	case document.FieldSenderID:
		return m.SenderID()
	case document.FieldCreatedBy:
		return m.CreatedBy()
	case document.FieldUpdatedBy:
		return m.UpdatedBy()
	case document.FieldCreatedAt:
		return m.CreatedAt()
	case document.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case document.FieldFolderID:
		return m.OldFolderID(ctx)
	case document.FieldName:
		return m.OldName(ctx)
	case document.FieldFilePath:
		return m.OldFilePath(ctx)
	case document.FieldPreviewFilePath:
		return m.OldPreviewFilePath(ctx)
	case document.FieldFileSize:
		return m.OldFileSize(ctx)
	case document.FieldMimeType:
		return m.OldMimeType(ctx)
	case document.FieldChecksum:
		return m.OldChecksum(ctx)
	case document.FieldSenderID:
		return m.OldSenderID(ctx)
	case document.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case document.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case document.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case document.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldCompanyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case document.FieldFolderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolderID(v)
		return nil
	case document.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case document.FieldFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilePath(v)
		return nil
	case document.FieldPreviewFilePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPreviewFilePath(v)
		return nil
	case document.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileSize(v)
		return nil
	case document.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case document.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case document.FieldSenderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSenderID(v)
		return nil
	case document.FieldCreatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case document.FieldUpdatedBy:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case document.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case document.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	var fields []string
	if m.addfile_size != nil {
		fields = append(fields, document.FieldFileSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case document.FieldFileSize:
		return m.AddedFileSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case document.FieldFileSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileSize(v)
		return nil
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(document.FieldFolderID) {
		fields = append(fields, document.FieldFolderID)
	}
	if m.FieldCleared(document.FieldPreviewFilePath) {
		fields = append(fields, document.FieldPreviewFilePath)
	}
	if m.FieldCleared(document.FieldSenderID) {
		fields = append(fields, document.FieldSenderID)
	}
	if m.FieldCleared(document.FieldCreatedBy) {
		fields = append(fields, document.FieldCreatedBy)
	}
	if m.FieldCleared(document.FieldUpdatedBy) {
		fields = append(fields, document.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	switch name {
	case document.FieldFolderID:
		m.ClearFolderID()
		return nil
	case document.FieldPreviewFilePath:
		m.ClearPreviewFilePath()
		return nil
	case document.FieldSenderID:
		m.ClearSenderID()
		return nil
	case document.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case document.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case document.FieldFolderID:
		m.ResetFolderID()
		return nil
	case document.FieldName:
		m.ResetName()
		return nil
	case document.FieldFilePath:
		m.ResetFilePath()
		return nil
	case document.FieldPreviewFilePath:
		m.ResetPreviewFilePath()
		return nil
	case document.FieldFileSize:
		m.ResetFileSize()
		return nil
	case document.FieldMimeType:
		m.ResetMimeType()
		return nil
	case document.FieldChecksum:
		m.ResetChecksum()
		return nil
	case document.FieldSenderID:
		m.ResetSenderID()
		return nil
	case document.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case document.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case document.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case document.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.company != nil {
		edges = append(edges, document.EdgeCompany)
	}
	if m.folder != nil {
		edges = append(edges, document.EdgeFolder)
	}
	if m.sender != nil {
		edges = append(edges, document.EdgeSender)
	}
	if m.created_by_user != nil {
		edges = append(edges, document.EdgeCreatedByUser)
	}
	if m.updated_by_user != nil {
		edges = append(edges, document.EdgeUpdatedByUser)
	}
	if m.document_tags != nil {
		edges = append(edges, document.EdgeDocumentTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeFolder:
		if id := m.folder; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeCreatedByUser:
		if id := m.created_by_user; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeUpdatedByUser:
		if id := m.updated_by_user; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeDocumentTags:
		ids := make([]ent.Value, 0, len(m.document_tags))
		for id := range m.document_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removeddocument_tags != nil {
		edges = append(edges, document.EdgeDocumentTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeDocumentTags:
		ids := make([]ent.Value, 0, len(m.removeddocument_tags))
		for id := range m.removeddocument_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedcompany {
		edges = append(edges, document.EdgeCompany)
	}
	if m.clearedfolder {
		edges = append(edges, document.EdgeFolder)
	}
	if m.clearedsender {
		edges = append(edges, document.EdgeSender)
	}
	if m.clearedcreated_by_user {
		edges = append(edges, document.EdgeCreatedByUser)
	}
	if m.clearedupdated_by_user {
		edges = append(edges, document.EdgeUpdatedByUser)
	}
	if m.cleareddocument_tags {
		edges = append(edges, document.EdgeDocumentTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeCompany:
		return m.clearedcompany
	case document.EdgeFolder:
		return m.clearedfolder
	case document.EdgeSender:
		return m.clearedsender
	case document.EdgeCreatedByUser:
		return m.clearedcreated_by_user
	case document.EdgeUpdatedByUser:
		return m.clearedupdated_by_user
	case document.EdgeDocumentTags:
		return m.cleareddocument_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeCompany:
		m.ClearCompany()
		return nil
	case document.EdgeFolder:
		m.ClearFolder()
		return nil
	case document.EdgeSender:
		m.ClearSender()
		return nil
	case document.EdgeCreatedByUser:
		m.ClearCreatedByUser()
		return nil
	case document.EdgeUpdatedByUser:
		m.ClearUpdatedByUser()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeCompany:
		m.ResetCompany()
		return nil
	case document.EdgeFolder:
		m.ResetFolder()
		return nil
	case document.EdgeSender:
		m.ResetSender()
		return nil
	case document.EdgeCreatedByUser:
		m.ResetCreatedByUser()
		return nil
	case document.EdgeUpdatedByUser:
		m.ResetUpdatedByUser()
		return nil
	case document.EdgeDocumentTags:
		m.ResetDocumentTags()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// DocumentTagMutation represents an operation that mutates the DocumentTag nodes in the graph.
type DocumentTagMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	document_id     *uuid.UUID
	tag_id          *uuid.UUID
	clearedFields   map[string]struct{}
	document        map[uuid.UUID]struct{}
	removeddocument map[uuid.UUID]struct{}
	cleareddocument bool
	tag             map[uuid.UUID]struct{}
	removedtag      map[uuid.UUID]struct{}
	clearedtag      bool
	done            bool
	oldValue        func(context.Context) (*DocumentTag, error)
	predicates      []predicate.DocumentTag
}

var _ ent.Mutation = (*DocumentTagMutation)(nil)

// documenttagOption allows management of the mutation configuration using functional options.
type documenttagOption func(*DocumentTagMutation)

// newDocumentTagMutation creates new mutation for the DocumentTag entity.
func newDocumentTagMutation(c config, op Op, opts ...documenttagOption) *DocumentTagMutation {
	m := &DocumentTagMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentTagID sets the ID field of the mutation.
func withDocumentTagID(id uuid.UUID) documenttagOption {
	return func(m *DocumentTagMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentTag
		)
		m.oldValue = func(ctx context.Context) (*DocumentTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentTag sets the old DocumentTag of the mutation.
func withDocumentTag(node *DocumentTag) documenttagOption {
	return func(m *DocumentTagMutation) {
		m.oldValue = func(context.Context) (*DocumentTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentTag entities.
func (m *DocumentTagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentTagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentTagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDocumentID sets the "document_id" field.
func (m *DocumentTagMutation) SetDocumentID(u uuid.UUID) {
	m.document_id = &u
}

// DocumentID returns the value of the "document_id" field in the mutation.
func (m *DocumentTagMutation) DocumentID() (r uuid.UUID, exists bool) {
	v := m.document_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentID returns the old "document_id" field's value of the DocumentTag entity.
// If the DocumentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTagMutation) OldDocumentID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentID: %w", err)
	}
	return oldValue.DocumentID, nil
}

// ResetDocumentID resets all changes to the "document_id" field.
func (m *DocumentTagMutation) ResetDocumentID() {
	m.document_id = nil
}

// SetTagID sets the "tag_id" field.
func (m *DocumentTagMutation) SetTagID(u uuid.UUID) {
	m.tag_id = &u
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *DocumentTagMutation) TagID() (r uuid.UUID, exists bool) {
	v := m.tag_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the DocumentTag entity.
// If the DocumentTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTagMutation) OldTagID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *DocumentTagMutation) ResetTagID() {
	m.tag_id = nil
}

// AddDocumentIDs adds the "document" edge to the Document entity by ids.
func (m *DocumentTagMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.document == nil {
		m.document = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document[ids[i]] = struct{}{}
	}
}

// ClearDocument clears the "document" edge to the Document entity.
func (m *DocumentTagMutation) ClearDocument() {
	m.cleareddocument = true
}

// DocumentCleared reports if the "document" edge to the Document entity was cleared.
func (m *DocumentTagMutation) DocumentCleared() bool {
	return m.cleareddocument
}

// RemoveDocumentIDs removes the "document" edge to the Document entity by IDs.
func (m *DocumentTagMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocument == nil {
		m.removeddocument = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document, ids[i])
		m.removeddocument[ids[i]] = struct{}{}
	}
}

// RemovedDocument returns the removed IDs of the "document" edge to the Document entity.
func (m *DocumentTagMutation) RemovedDocumentIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument {
		ids = append(ids, id)
	}
	return
}

// DocumentIDs returns the "document" edge IDs in the mutation.
func (m *DocumentTagMutation) DocumentIDs() (ids []uuid.UUID) {
	for id := range m.document {
		ids = append(ids, id)
	}
	return
}

// ResetDocument resets all changes to the "document" edge.
func (m *DocumentTagMutation) ResetDocument() {
	m.document = nil
	m.cleareddocument = false
	m.removeddocument = nil
}

// AddTagIDs adds the "tag" edge to the Tag entity by ids.
func (m *DocumentTagMutation) AddTagIDs(ids ...uuid.UUID) {
	if m.tag == nil {
		m.tag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.tag[ids[i]] = struct{}{}
	}
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *DocumentTagMutation) ClearTag() {
	m.clearedtag = true
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *DocumentTagMutation) TagCleared() bool {
	return m.clearedtag
}

// RemoveTagIDs removes the "tag" edge to the Tag entity by IDs.
func (m *DocumentTagMutation) RemoveTagIDs(ids ...uuid.UUID) {
	if m.removedtag == nil {
		m.removedtag = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.tag, ids[i])
		m.removedtag[ids[i]] = struct{}{}
	}
}

// RemovedTag returns the removed IDs of the "tag" edge to the Tag entity.
func (m *DocumentTagMutation) RemovedTagIDs() (ids []uuid.UUID) {
	for id := range m.removedtag {
		ids = append(ids, id)
	}
	return
}

// TagIDs returns the "tag" edge IDs in the mutation.
func (m *DocumentTagMutation) TagIDs() (ids []uuid.UUID) {
	for id := range m.tag {
		ids = append(ids, id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *DocumentTagMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
	m.removedtag = nil
}

// Where appends a list predicates to the DocumentTagMutation builder.
func (m *DocumentTagMutation) Where(ps ...predicate.DocumentTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentTag).
func (m *DocumentTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.document_id != nil {
		fields = append(fields, documenttag.FieldDocumentID)
	}
	if m.tag_id != nil {
		fields = append(fields, documenttag.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documenttag.FieldDocumentID:
		return m.DocumentID()
	case documenttag.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documenttag.FieldDocumentID:
		return m.OldDocumentID(ctx)
	case documenttag.FieldTagID:
		return m.OldTagID(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documenttag.FieldDocumentID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentID(v)
		return nil
	case documenttag.FieldTagID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DocumentTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentTagMutation) ResetField(name string) error {
	switch name {
	case documenttag.FieldDocumentID:
		m.ResetDocumentID()
		return nil
	case documenttag.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown DocumentTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.document != nil {
		edges = append(edges, documenttag.EdgeDocument)
	}
	if m.tag != nil {
		edges = append(edges, documenttag.EdgeTag)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documenttag.EdgeDocument:
		ids := make([]ent.Value, 0, len(m.document))
		for id := range m.document {
			ids = append(ids, id)
		}
		return ids
	case documenttag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.tag))
		for id := range m.tag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddocument != nil {
		edges = append(edges, documenttag.EdgeDocument)
	}
	if m.removedtag != nil {
		edges = append(edges, documenttag.EdgeTag)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case documenttag.EdgeDocument:
		ids := make([]ent.Value, 0, len(m.removeddocument))
		for id := range m.removeddocument {
			ids = append(ids, id)
		}
		return ids
	case documenttag.EdgeTag:
		ids := make([]ent.Value, 0, len(m.removedtag))
		for id := range m.removedtag {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddocument {
		edges = append(edges, documenttag.EdgeDocument)
	}
	if m.clearedtag {
		edges = append(edges, documenttag.EdgeTag)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentTagMutation) EdgeCleared(name string) bool {
	switch name {
	case documenttag.EdgeDocument:
		return m.cleareddocument
	case documenttag.EdgeTag:
		return m.clearedtag
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentTagMutation) ResetEdge(name string) error {
	switch name {
	case documenttag.EdgeDocument:
		m.ResetDocument()
		return nil
	case documenttag.EdgeTag:
		m.ResetTag()
		return nil
	}
	return fmt.Errorf("unknown DocumentTag edge %s", name)
}

// FolderMutation represents an operation that mutates the Folder nodes in the graph.
type FolderMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	size             *int64
	addsize          *int64
	count            *int
	addcount         *int
	clearedFields    map[string]struct{}
	company          *uuid.UUID
	clearedcompany   bool
	parent           *uuid.UUID
	clearedparent    bool
	children         map[uuid.UUID]struct{}
	removedchildren  map[uuid.UUID]struct{}
	clearedchildren  bool
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	done             bool
	oldValue         func(context.Context) (*Folder, error)
	predicates       []predicate.Folder
}

var _ ent.Mutation = (*FolderMutation)(nil)

// folderOption allows management of the mutation configuration using functional options.
type folderOption func(*FolderMutation)

// newFolderMutation creates new mutation for the Folder entity.
func newFolderMutation(c config, op Op, opts ...folderOption) *FolderMutation {
	m := &FolderMutation{
		config:        c,
		op:            op,
		typ:           TypeFolder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFolderID sets the ID field of the mutation.
func withFolderID(id uuid.UUID) folderOption {
	return func(m *FolderMutation) {
		var (
			err   error
			once  sync.Once
			value *Folder
		)
		m.oldValue = func(ctx context.Context) (*Folder, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Folder.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFolder sets the old Folder of the mutation.
func withFolder(node *Folder) folderOption {
	return func(m *FolderMutation) {
		m.oldValue = func(context.Context) (*Folder, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FolderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FolderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Folder entities.
func (m *FolderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FolderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FolderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Folder.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *FolderMutation) SetCompanyID(u uuid.UUID) {
	m.company = &u
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *FolderMutation) CompanyID() (r uuid.UUID, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldCompanyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *FolderMutation) ResetCompanyID() {
	m.company = nil
}

// SetParentFolderID sets the "parent_folder_id" field.
func (m *FolderMutation) SetParentFolderID(u uuid.UUID) {
	m.parent = &u
}

// ParentFolderID returns the value of the "parent_folder_id" field in the mutation.
func (m *FolderMutation) ParentFolderID() (r uuid.UUID, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentFolderID returns the old "parent_folder_id" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldParentFolderID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentFolderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentFolderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentFolderID: %w", err)
	}
	return oldValue.ParentFolderID, nil
}

// ClearParentFolderID clears the value of the "parent_folder_id" field.
func (m *FolderMutation) ClearParentFolderID() {
	m.parent = nil
	m.clearedFields[folder.FieldParentFolderID] = struct{}{}
}

// ParentFolderIDCleared returns if the "parent_folder_id" field was cleared in this mutation.
func (m *FolderMutation) ParentFolderIDCleared() bool {
	_, ok := m.clearedFields[folder.FieldParentFolderID]
	return ok
}

// ResetParentFolderID resets all changes to the "parent_folder_id" field.
func (m *FolderMutation) ResetParentFolderID() {
	m.parent = nil
	delete(m.clearedFields, folder.FieldParentFolderID)
}

// SetName sets the "name" field.
func (m *FolderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FolderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FolderMutation) ResetName() {
	m.name = nil
}

// SetSize sets the "size" field.
func (m *FolderMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *FolderMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *FolderMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *FolderMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *FolderMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetCount sets the "count" field.
func (m *FolderMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *FolderMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Folder entity.
// If the Folder object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FolderMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *FolderMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *FolderMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *FolderMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *FolderMutation) ClearCompany() {
	m.clearedcompany = true
	m.clearedFields[folder.FieldCompanyID] = struct{}{}
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *FolderMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *FolderMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *FolderMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetParentID sets the "parent" edge to the Folder entity by id.
func (m *FolderMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Folder entity.
func (m *FolderMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[folder.FieldParentFolderID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the Folder entity was cleared.
func (m *FolderMutation) ParentCleared() bool {
	return m.ParentFolderIDCleared() || m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FolderMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FolderMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FolderMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Folder entity by ids.
func (m *FolderMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Folder entity.
func (m *FolderMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Folder entity was cleared.
func (m *FolderMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Folder entity by IDs.
func (m *FolderMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Folder entity.
func (m *FolderMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FolderMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FolderMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *FolderMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *FolderMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *FolderMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *FolderMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *FolderMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *FolderMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *FolderMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the FolderMutation builder.
func (m *FolderMutation) Where(ps ...predicate.Folder) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FolderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FolderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Folder, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FolderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FolderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Folder).
func (m *FolderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FolderMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.company != nil {
		fields = append(fields, folder.FieldCompanyID)
	}
	if m.parent != nil {
		fields = append(fields, folder.FieldParentFolderID)
	}
	if m.name != nil {
		fields = append(fields, folder.FieldName)
	}
	if m.size != nil {
		fields = append(fields, folder.FieldSize)
	}
	if m.count != nil {
		fields = append(fields, folder.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FolderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case folder.FieldCompanyID:
		return m.CompanyID()
	case folder.FieldParentFolderID:
		return m.ParentFolderID()
	case folder.FieldName:
		return m.Name()
	case folder.FieldSize:
		return m.Size()
	case folder.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FolderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case folder.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case folder.FieldParentFolderID:
		return m.OldParentFolderID(ctx)
	case folder.FieldName:
		return m.OldName(ctx)
	case folder.FieldSize:
		return m.OldSize(ctx)
	case folder.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown Folder field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FolderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case folder.FieldCompanyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case folder.FieldParentFolderID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentFolderID(v)
		return nil
	case folder.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case folder.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case folder.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown Folder field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FolderMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, folder.FieldSize)
	}
	if m.addcount != nil {
		fields = append(fields, folder.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FolderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case folder.FieldSize:
		return m.AddedSize()
	case folder.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FolderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case folder.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case folder.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown Folder numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FolderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(folder.FieldParentFolderID) {
		fields = append(fields, folder.FieldParentFolderID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FolderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FolderMutation) ClearField(name string) error {
	switch name {
	case folder.FieldParentFolderID:
		m.ClearParentFolderID()
		return nil
	}
	return fmt.Errorf("unknown Folder nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FolderMutation) ResetField(name string) error {
	switch name {
	case folder.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case folder.FieldParentFolderID:
		m.ResetParentFolderID()
		return nil
	case folder.FieldName:
		m.ResetName()
		return nil
	case folder.FieldSize:
		m.ResetSize()
		return nil
	case folder.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown Folder field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FolderMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.company != nil {
		edges = append(edges, folder.EdgeCompany)
	}
	if m.parent != nil {
		edges = append(edges, folder.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, folder.EdgeChildren)
	}
	if m.documents != nil {
		edges = append(edges, folder.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FolderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case folder.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case folder.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case folder.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FolderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, folder.EdgeChildren)
	}
	if m.removeddocuments != nil {
		edges = append(edges, folder.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FolderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case folder.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case folder.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FolderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcompany {
		edges = append(edges, folder.EdgeCompany)
	}
	if m.clearedparent {
		edges = append(edges, folder.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, folder.EdgeChildren)
	}
	if m.cleareddocuments {
		edges = append(edges, folder.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FolderMutation) EdgeCleared(name string) bool {
	switch name {
	case folder.EdgeCompany:
		return m.clearedcompany
	case folder.EdgeParent:
		return m.clearedparent
	case folder.EdgeChildren:
		return m.clearedchildren
	case folder.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FolderMutation) ClearEdge(name string) error {
	switch name {
	case folder.EdgeCompany:
		m.ClearCompany()
		return nil
	case folder.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Folder unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FolderMutation) ResetEdge(name string) error {
	switch name {
	case folder.EdgeCompany:
		m.ResetCompany()
		return nil
	case folder.EdgeParent:
		m.ResetParent()
		return nil
	case folder.EdgeChildren:
		m.ResetChildren()
		return nil
	case folder.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown Folder edge %s", name)
}

// SenderMutation represents an operation that mutates the Sender nodes in the graph.
type SenderMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	email            *string
	clearedFields    map[string]struct{}
	documents        map[uuid.UUID]struct{}
	removeddocuments map[uuid.UUID]struct{}
	cleareddocuments bool
	done             bool
	oldValue         func(context.Context) (*Sender, error)
	predicates       []predicate.Sender
}

var _ ent.Mutation = (*SenderMutation)(nil)

// senderOption allows management of the mutation configuration using functional options.
type senderOption func(*SenderMutation)

// newSenderMutation creates new mutation for the Sender entity.
func newSenderMutation(c config, op Op, opts ...senderOption) *SenderMutation {
	m := &SenderMutation{
		config:        c,
		op:            op,
		typ:           TypeSender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSenderID sets the ID field of the mutation.
func withSenderID(id uuid.UUID) senderOption {
	return func(m *SenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Sender
		)
		m.oldValue = func(ctx context.Context) (*Sender, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Sender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSender sets the old Sender of the mutation.
func withSender(node *Sender) senderOption {
	return func(m *SenderMutation) {
		m.oldValue = func(context.Context) (*Sender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Sender entities.
func (m *SenderMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SenderMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SenderMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Sender.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SenderMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SenderMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Sender entity.
// If the Sender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SenderMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SenderMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *SenderMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *SenderMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Sender entity.
// If the Sender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SenderMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *SenderMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[sender.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *SenderMutation) EmailCleared() bool {
	_, ok := m.clearedFields[sender.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *SenderMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, sender.FieldEmail)
}

// AddDocumentIDs adds the "documents" edge to the Document entity by ids.
func (m *SenderMutation) AddDocumentIDs(ids ...uuid.UUID) {
	if m.documents == nil {
		m.documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.documents[ids[i]] = struct{}{}
	}
}

// ClearDocuments clears the "documents" edge to the Document entity.
func (m *SenderMutation) ClearDocuments() {
	m.cleareddocuments = true
}

// DocumentsCleared reports if the "documents" edge to the Document entity was cleared.
func (m *SenderMutation) DocumentsCleared() bool {
	return m.cleareddocuments
}

// RemoveDocumentIDs removes the "documents" edge to the Document entity by IDs.
func (m *SenderMutation) RemoveDocumentIDs(ids ...uuid.UUID) {
	if m.removeddocuments == nil {
		m.removeddocuments = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.documents, ids[i])
		m.removeddocuments[ids[i]] = struct{}{}
	}
}

// RemovedDocuments returns the removed IDs of the "documents" edge to the Document entity.
func (m *SenderMutation) RemovedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocuments {
		ids = append(ids, id)
	}
	return
}

// DocumentsIDs returns the "documents" edge IDs in the mutation.
func (m *SenderMutation) DocumentsIDs() (ids []uuid.UUID) {
	for id := range m.documents {
		ids = append(ids, id)
	}
	return
}

// ResetDocuments resets all changes to the "documents" edge.
func (m *SenderMutation) ResetDocuments() {
	m.documents = nil
	m.cleareddocuments = false
	m.removeddocuments = nil
}

// Where appends a list predicates to the SenderMutation builder.
func (m *SenderMutation) Where(ps ...predicate.Sender) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SenderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SenderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Sender, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SenderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SenderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Sender).
func (m *SenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SenderMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, sender.FieldName)
	}
	if m.email != nil {
		fields = append(fields, sender.FieldEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case sender.FieldName:
		return m.Name()
	case sender.FieldEmail:
		return m.Email()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case sender.FieldName:
		return m.OldName(ctx)
	case sender.FieldEmail:
		return m.OldEmail(ctx)
	}
	return nil, fmt.Errorf("unknown Sender field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case sender.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case sender.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	}
	return fmt.Errorf("unknown Sender field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Sender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SenderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(sender.FieldEmail) {
		fields = append(fields, sender.FieldEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SenderMutation) ClearField(name string) error {
	switch name {
	case sender.FieldEmail:
		m.ClearEmail()
		return nil
	}
	return fmt.Errorf("unknown Sender nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SenderMutation) ResetField(name string) error {
	switch name {
	case sender.FieldName:
		m.ResetName()
		return nil
	case sender.FieldEmail:
		m.ResetEmail()
		return nil
	}
	return fmt.Errorf("unknown Sender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.documents != nil {
		edges = append(edges, sender.EdgeDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case sender.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.documents))
		for id := range m.documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddocuments != nil {
		edges = append(edges, sender.EdgeDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case sender.EdgeDocuments:
		ids := make([]ent.Value, 0, len(m.removeddocuments))
		for id := range m.removeddocuments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddocuments {
		edges = append(edges, sender.EdgeDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SenderMutation) EdgeCleared(name string) bool {
	switch name {
	case sender.EdgeDocuments:
		return m.cleareddocuments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Sender unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SenderMutation) ResetEdge(name string) error {
	switch name {
	case sender.EdgeDocuments:
		m.ResetDocuments()
		return nil
	}
	return fmt.Errorf("unknown Sender edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	name                 *string
	clearedFields        map[string]struct{}
	company              *uuid.UUID
	clearedcompany       bool
	document_tags        map[uuid.UUID]struct{}
	removeddocument_tags map[uuid.UUID]struct{}
	cleareddocument_tags bool
	done                 bool
	oldValue             func(context.Context) (*Tag, error)
	predicates           []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id uuid.UUID) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCompanyID sets the "company_id" field.
func (m *TagMutation) SetCompanyID(u uuid.UUID) {
	m.company = &u
}

// CompanyID returns the value of the "company_id" field in the mutation.
func (m *TagMutation) CompanyID() (r uuid.UUID, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyID returns the old "company_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldCompanyID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyID: %w", err)
	}
	return oldValue.CompanyID, nil
}

// ResetCompanyID resets all changes to the "company_id" field.
func (m *TagMutation) ResetCompanyID() {
	m.company = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TagMutation) ClearCompany() {
	m.clearedcompany = true
	m.clearedFields[tag.FieldCompanyID] = struct{}{}
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TagMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TagMutation) CompanyIDs() (ids []uuid.UUID) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TagMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// AddDocumentTagIDs adds the "document_tags" edge to the DocumentTag entity by ids.
func (m *TagMutation) AddDocumentTagIDs(ids ...uuid.UUID) {
	if m.document_tags == nil {
		m.document_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.document_tags[ids[i]] = struct{}{}
	}
}

// ClearDocumentTags clears the "document_tags" edge to the DocumentTag entity.
func (m *TagMutation) ClearDocumentTags() {
	m.cleareddocument_tags = true
}

// DocumentTagsCleared reports if the "document_tags" edge to the DocumentTag entity was cleared.
func (m *TagMutation) DocumentTagsCleared() bool {
	return m.cleareddocument_tags
}

// RemoveDocumentTagIDs removes the "document_tags" edge to the DocumentTag entity by IDs.
func (m *TagMutation) RemoveDocumentTagIDs(ids ...uuid.UUID) {
	if m.removeddocument_tags == nil {
		m.removeddocument_tags = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.document_tags, ids[i])
		m.removeddocument_tags[ids[i]] = struct{}{}
	}
}

// RemovedDocumentTags returns the removed IDs of the "document_tags" edge to the DocumentTag entity.
func (m *TagMutation) RemovedDocumentTagsIDs() (ids []uuid.UUID) {
	for id := range m.removeddocument_tags {
		ids = append(ids, id)
	}
	return
}

// DocumentTagsIDs returns the "document_tags" edge IDs in the mutation.
func (m *TagMutation) DocumentTagsIDs() (ids []uuid.UUID) {
	for id := range m.document_tags {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentTags resets all changes to the "document_tags" edge.
func (m *TagMutation) ResetDocumentTags() {
	m.document_tags = nil
	m.cleareddocument_tags = false
	m.removeddocument_tags = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.company != nil {
		fields = append(fields, tag.FieldCompanyID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldCompanyID:
		return m.CompanyID()
	case tag.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldCompanyID:
		return m.OldCompanyID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldCompanyID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldCompanyID:
		m.ResetCompanyID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.company != nil {
		edges = append(edges, tag.EdgeCompany)
	}
	if m.document_tags != nil {
		edges = append(edges, tag.EdgeDocumentTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeDocumentTags:
		ids := make([]ent.Value, 0, len(m.document_tags))
		for id := range m.document_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddocument_tags != nil {
		edges = append(edges, tag.EdgeDocumentTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeDocumentTags:
		ids := make([]ent.Value, 0, len(m.removeddocument_tags))
		for id := range m.removeddocument_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcompany {
		edges = append(edges, tag.EdgeCompany)
	}
	if m.cleareddocument_tags {
		edges = append(edges, tag.EdgeDocumentTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeCompany:
		return m.clearedcompany
	case tag.EdgeDocumentTags:
		return m.cleareddocument_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeCompany:
		m.ClearCompany()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeCompany:
		m.ResetCompany()
		return nil
	case tag.EdgeDocumentTags:
		m.ResetDocumentTags()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                       Op
	typ                      string
	id                       *uuid.UUID
	name                     *string
	email                    *string
	password                 *string
	clearedFields            map[string]struct{}
	company_users            map[uuid.UUID]struct{}
	removedcompany_users     map[uuid.UUID]struct{}
	clearedcompany_users     bool
	created_documents        map[uuid.UUID]struct{}
	removedcreated_documents map[uuid.UUID]struct{}
	clearedcreated_documents bool
	updated_documents        map[uuid.UUID]struct{}
	removedupdated_documents map[uuid.UUID]struct{}
	clearedupdated_documents bool
	done                     bool
	oldValue                 func(context.Context) (*User, error)
	predicates               []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// AddCompanyUserIDs adds the "company_users" edge to the CompanyUser entity by ids.
func (m *UserMutation) AddCompanyUserIDs(ids ...uuid.UUID) {
	if m.company_users == nil {
		m.company_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.company_users[ids[i]] = struct{}{}
	}
}

// ClearCompanyUsers clears the "company_users" edge to the CompanyUser entity.
func (m *UserMutation) ClearCompanyUsers() {
	m.clearedcompany_users = true
}

// CompanyUsersCleared reports if the "company_users" edge to the CompanyUser entity was cleared.
func (m *UserMutation) CompanyUsersCleared() bool {
	return m.clearedcompany_users
}

// RemoveCompanyUserIDs removes the "company_users" edge to the CompanyUser entity by IDs.
func (m *UserMutation) RemoveCompanyUserIDs(ids ...uuid.UUID) {
	if m.removedcompany_users == nil {
		m.removedcompany_users = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.company_users, ids[i])
		m.removedcompany_users[ids[i]] = struct{}{}
	}
}

// RemovedCompanyUsers returns the removed IDs of the "company_users" edge to the CompanyUser entity.
func (m *UserMutation) RemovedCompanyUsersIDs() (ids []uuid.UUID) {
	for id := range m.removedcompany_users {
		ids = append(ids, id)
	}
	return
}

// CompanyUsersIDs returns the "company_users" edge IDs in the mutation.
func (m *UserMutation) CompanyUsersIDs() (ids []uuid.UUID) {
	for id := range m.company_users {
		ids = append(ids, id)
	}
	return
}

// ResetCompanyUsers resets all changes to the "company_users" edge.
func (m *UserMutation) ResetCompanyUsers() {
	m.company_users = nil
	m.clearedcompany_users = false
	m.removedcompany_users = nil
}

// AddCreatedDocumentIDs adds the "created_documents" edge to the Document entity by ids.
func (m *UserMutation) AddCreatedDocumentIDs(ids ...uuid.UUID) {
	if m.created_documents == nil {
		m.created_documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.created_documents[ids[i]] = struct{}{}
	}
}

// ClearCreatedDocuments clears the "created_documents" edge to the Document entity.
func (m *UserMutation) ClearCreatedDocuments() {
	m.clearedcreated_documents = true
}

// CreatedDocumentsCleared reports if the "created_documents" edge to the Document entity was cleared.
func (m *UserMutation) CreatedDocumentsCleared() bool {
	return m.clearedcreated_documents
}

// RemoveCreatedDocumentIDs removes the "created_documents" edge to the Document entity by IDs.
func (m *UserMutation) RemoveCreatedDocumentIDs(ids ...uuid.UUID) {
	if m.removedcreated_documents == nil {
		m.removedcreated_documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.created_documents, ids[i])
		m.removedcreated_documents[ids[i]] = struct{}{}
	}
}

// RemovedCreatedDocuments returns the removed IDs of the "created_documents" edge to the Document entity.
func (m *UserMutation) RemovedCreatedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removedcreated_documents {
		ids = append(ids, id)
	}
	return
}

// CreatedDocumentsIDs returns the "created_documents" edge IDs in the mutation.
func (m *UserMutation) CreatedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.created_documents {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedDocuments resets all changes to the "created_documents" edge.
func (m *UserMutation) ResetCreatedDocuments() {
	m.created_documents = nil
	m.clearedcreated_documents = false
	m.removedcreated_documents = nil
}

// AddUpdatedDocumentIDs adds the "updated_documents" edge to the Document entity by ids.
func (m *UserMutation) AddUpdatedDocumentIDs(ids ...uuid.UUID) {
	if m.updated_documents == nil {
		m.updated_documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.updated_documents[ids[i]] = struct{}{}
	}
}

// ClearUpdatedDocuments clears the "updated_documents" edge to the Document entity.
func (m *UserMutation) ClearUpdatedDocuments() {
	m.clearedupdated_documents = true
}

// UpdatedDocumentsCleared reports if the "updated_documents" edge to the Document entity was cleared.
func (m *UserMutation) UpdatedDocumentsCleared() bool {
	return m.clearedupdated_documents
}

// RemoveUpdatedDocumentIDs removes the "updated_documents" edge to the Document entity by IDs.
func (m *UserMutation) RemoveUpdatedDocumentIDs(ids ...uuid.UUID) {
	if m.removedupdated_documents == nil {
		m.removedupdated_documents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.updated_documents, ids[i])
		m.removedupdated_documents[ids[i]] = struct{}{}
	}
}

// RemovedUpdatedDocuments returns the removed IDs of the "updated_documents" edge to the Document entity.
func (m *UserMutation) RemovedUpdatedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.removedupdated_documents {
		ids = append(ids, id)
	}
	return
}

// UpdatedDocumentsIDs returns the "updated_documents" edge IDs in the mutation.
func (m *UserMutation) UpdatedDocumentsIDs() (ids []uuid.UUID) {
	for id := range m.updated_documents {
		ids = append(ids, id)
	}
	return
}

// ResetUpdatedDocuments resets all changes to the "updated_documents" edge.
func (m *UserMutation) ResetUpdatedDocuments() {
	m.updated_documents = nil
	m.clearedupdated_documents = false
	m.removedupdated_documents = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.company_users != nil {
		edges = append(edges, user.EdgeCompanyUsers)
	}
	if m.created_documents != nil {
		edges = append(edges, user.EdgeCreatedDocuments)
	}
	if m.updated_documents != nil {
		edges = append(edges, user.EdgeUpdatedDocuments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCompanyUsers:
		ids := make([]ent.Value, 0, len(m.company_users))
		for id := range m.company_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedDocuments:
		ids := make([]ent.Value, 0, len(m.created_documents))
		for id := range m.created_documents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedDocuments:
		ids := make([]ent.Value, 0, len(m.updated_documents))
		for id := range m.updated_documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcompany_users != nil {
		edges = append(edges, user.EdgeCompanyUsers)
	}
	if m.removedcreated_documents != nil {
		edges = append(edges, user.EdgeCreatedDocuments)
	}
	if m.removedupdated_documents != nil {
		edges = append(edges, user.EdgeUpdatedDocuments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeCompanyUsers:
		ids := make([]ent.Value, 0, len(m.removedcompany_users))
		for id := range m.removedcompany_users {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedDocuments:
		ids := make([]ent.Value, 0, len(m.removedcreated_documents))
		for id := range m.removedcreated_documents {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUpdatedDocuments:
		ids := make([]ent.Value, 0, len(m.removedupdated_documents))
		for id := range m.removedupdated_documents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcompany_users {
		edges = append(edges, user.EdgeCompanyUsers)
	}
	if m.clearedcreated_documents {
		edges = append(edges, user.EdgeCreatedDocuments)
	}
	if m.clearedupdated_documents {
		edges = append(edges, user.EdgeUpdatedDocuments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeCompanyUsers:
		return m.clearedcompany_users
	case user.EdgeCreatedDocuments:
		return m.clearedcreated_documents
	case user.EdgeUpdatedDocuments:
		return m.clearedupdated_documents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeCompanyUsers:
		m.ResetCompanyUsers()
		return nil
	case user.EdgeCreatedDocuments:
		m.ResetCreatedDocuments()
		return nil
	case user.EdgeUpdatedDocuments:
		m.ResetUpdatedDocuments()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
